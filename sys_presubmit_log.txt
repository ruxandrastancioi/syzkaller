make presubmit_smoke
make generate
make descriptions
go list -f '{{.Stale}}' ./sys/syz-sysgen | grep -q false || go install ./sys/syz-sysgen
make .descriptions
make[4]: '.descriptions' is up to date.
make generate_go
clang-format --style=file -i executor/*.cc executor/*.h \
	executor/android/android_seccomp.h \
	tools/kcovtrace/*.c tools/kcovfuzzer/*.c tools/fops_probe/*.cc
go generate ./pkg/csource ./executor ./pkg/ifuzz ./pkg/build ./pkg/html
make format
go fmt ./...
clang-format --style=file -i executor/*.cc executor/*.h \
	executor/android/android_seccomp.h \
	tools/kcovtrace/*.c tools/kcovfuzzer/*.c tools/fops_probe/*.cc
go build "-ldflags=-s -w -X github.com/google/syzkaller/prog.GitRevision=c90fd2ff264dcbbd8611146eac810f8a719d0738+ -X 'github.com/google/syzkaller/prog.gitRevisionDate=Thu Jul 9 10:28:07 2020 +0000'" -o bin/syz-fmt ./tools/syz-fmt
bin/syz-fmt all
pkg/build/linux_generated.go
pkg/html/generated.go
pkg/ifuzz/generated/insns.go
make -j100 check_diff check_copyright check_language check_links presubmit_build
./tools/check-copyright.sh
./tools/check-language.sh
python ./tools/check_links.py $(pwd) $(ls ./*.md; find ./docs/ -name '*.md')
# Run go build before lint for better error messages if build is broken.
# This does not check build of test files, but running go test takes too long (even for building).
go build ./...
181 links checked: OK
664 files checked for copyright statement
make lint
# This should install the command from our vendor dir.
CGO_ENABLED=1 go install github.com/golangci/golangci-lint/cmd/golangci-lint
CGO_ENABLED=1 go build -buildmode=plugin -o bin/syz-linter.so ./tools/syz-linter
bin/golangci-lint run ./...
make test
go list -f '{{.Stale}}' ./sys/syz-sysgen | grep -q false || go install ./sys/syz-sysgen
make .descriptions
make[3]: '.descriptions' is up to date.
go test -short -coverprofile=.coverage.txt ./...
ok  	github.com/google/syzkaller/dashboard/app	0.143s	coverage: 4.8% of statements
?   	github.com/google/syzkaller/dashboard/dashapi	[no test files]
?   	github.com/google/syzkaller/executor	[no test files]
ok  	github.com/google/syzkaller/pkg/ast	0.661s	coverage: 90.0% of statements
ok  	github.com/google/syzkaller/pkg/bisect	14.394s	coverage: 75.9% of statements
ok  	github.com/google/syzkaller/pkg/build	2.474s	coverage: 15.4% of statements
?   	github.com/google/syzkaller/pkg/cmdprof	[no test files]
ok  	github.com/google/syzkaller/pkg/compiler	3.260s	coverage: 93.5% of statements
ok  	github.com/google/syzkaller/pkg/config	0.024s	coverage: 70.8% of statements
ok  	github.com/google/syzkaller/pkg/cover	5.300s	coverage: 79.0% of statements
--- FAIL: TestGenerate (5.21s)
    --- FAIL: TestGenerate/test/32_fork_shmem (0.01s)
        csource_test.go:66: seed=1594291485072974145
        --- FAIL: TestGenerate/test/32_fork_shmem/8 (0.05s)
            csource_test.go:122: opts: {Threaded:true Collide:false Repeat:true RepeatTimes:0 Procs:0 Sandbox:none Fault:false FaultCall:0 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false USB:false UseTmpDir:false HandleSegv:false Repro:false Trace:false}
                program:
                test$type_confusion1(&(0x7f0000000000)=@f1=0xff)
                mutate_buffer(&(0x7f0000000040)=""/237)
                test$bf0(&(0x7f0000000140)={0x0, 0x10001, 0x2, 0x2b, 0x42, 0x20, 0x20, 0x1f})
                syz_execute_func(&(0x7f0000000180)="de8d31221e443cba344f81dc1534bf8015a1350411ce2007d24ff18ab572199e089d6983919bba8dd629334b1773d95aeee8")
                test$text_x86_16(&(0x7f00000001c0)="66b9800000c00f326635000100000f30dd630062310f30660f3a0a179c362ef26f691dad46ba4100b88b00ef0f08f33e817709ec00", 0x35)
                foo$fmt0(&(0x7f0000000200)=0x7)
                foo$anyres(&(0x7f0000000240), &(0x7f0000000280))
                test$excessive_fields1(&(0x7f00000002c0)={0xff})
                test$excessive_fields1(&(0x7f0000000300)={0x17})
                test_length15(0x4, 0x2)
                syz_compare(&(0x7f0000000000)='\x00', 0x1, &(0x7f0000000040)=@align0={0x401, 0x4, 0x6, 0xfffc, 0x3}, 0x18)
                syz_compare_int$2(0x2, 0x2, 0x81)
                syz_errno(0xf4)
                syz_execute_func(&(0x7f0000000080)="942218be6a28edc5cd9dd79f084dc2395ec1de75c537240555032566d42e5e83d07432c482b4ec4a1e6ed599f7acf6e8a6df")
                syz_exit(0x100)
                syz_mmap(&(0x7f0000ffb000/0x2000)=nil, 0x2000)
                
            csource_test.go:123: failed to build program:
                // autogenerated by syzkaller (https://github.com/google/syzkaller)
                
                #define _GNU_SOURCE 
                
                #include <endian.h>
                #include <errno.h>
                #include <pthread.h>
                #include <signal.h>
                #include <stdarg.h>
                #include <stdint.h>
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <sys/mman.h>
                #include <sys/types.h>
                #include <sys/wait.h>
                #include <time.h>
                #include <unistd.h>
                
                static void kill_and_wait(int pid, int* status)
                {
                	kill(pid, SIGKILL);
                	while (waitpid(-1, status, 0) != pid) {
                	}
                }
                
                static void sleep_ms(uint64_t ms)
                {
                	usleep(ms * 1000);
                }
                
                static uint64_t current_time_ms(void)
                {
                	struct timespec ts;
                	if (clock_gettime(CLOCK_MONOTONIC, &ts))
                	exit(1);
                	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
                }
                
                static void thread_start(void* (*fn)(void*), void* arg)
                {
                	pthread_t th;
                	pthread_attr_t attr;
                	pthread_attr_init(&attr);
                	pthread_attr_setstacksize(&attr, 128 << 10);
                	int i;
                	for (i = 0; i < 100; i++) {
                		if (pthread_create(&th, &attr, fn, arg) == 0) {
                			pthread_attr_destroy(&attr);
                			return;
                		}
                		if (errno == EAGAIN) {
                			usleep(50);
                			continue;
                		}
                		break;
                	}
                	exit(1);
                }
                
                typedef struct {
                	pthread_mutex_t mu;
                	pthread_cond_t cv;
                	int state;
                } event_t;
                
                static void event_init(event_t* ev)
                {
                	if (pthread_mutex_init(&ev->mu, 0))
                	exit(1);
                	if (pthread_cond_init(&ev->cv, 0))
                	exit(1);
                	ev->state = 0;
                }
                
                static void event_reset(event_t* ev)
                {
                	ev->state = 0;
                }
                
                static void event_set(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	if (ev->state)
                	exit(1);
                	ev->state = 1;
                	pthread_mutex_unlock(&ev->mu);
                	pthread_cond_broadcast(&ev->cv);
                }
                
                static void event_wait(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	while (!ev->state)
                		pthread_cond_wait(&ev->cv, &ev->mu);
                	pthread_mutex_unlock(&ev->mu);
                }
                
                static int event_isset(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                static int event_timedwait(event_t* ev, uint64_t timeout)
                {
                	uint64_t start = current_time_ms();
                	uint64_t now = start;
                	pthread_mutex_lock(&ev->mu);
                	for (;;) {
                		if (ev->state)
                			break;
                		uint64_t remain = timeout - (now - start);
                		struct timespec ts;
                		ts.tv_sec = remain / 1000;
                		ts.tv_nsec = (remain % 1000) * 1000 * 1000;
                		pthread_cond_timedwait(&ev->cv, &ev->mu, &ts);
                		now = current_time_ms();
                		if (now - start > timeout)
                			break;
                	}
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                #define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
                #define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))
                
                static long syz_mmap(volatile long a0, volatile long a1)
                {
                	return (long)mmap((void*)a0, a1, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0);
                }
                
                static long syz_errno(volatile long v)
                {
                	errno = v;
                	return v == 0 ? 0 : -1;
                }
                
                static long syz_exit(volatile long status)
                {
                	_exit(status);
                	return 0;
                }
                
                static long syz_compare(volatile long want, volatile long want_len, volatile long got, volatile long got_len)
                {
                	if (want_len != got_len) {
                		errno = EBADF;
                		goto error;
                	}
                	if (memcmp((void*)want, (void*)got, want_len)) {
                		errno = EINVAL;
                		goto error;
                	}
                	return 0;
                
                error:
                	return -1;
                }
                
                static long syz_compare_int(volatile long n, ...)
                {
                	va_list args;
                	va_start(args, n);
                	long v0 = va_arg(args, long);
                	long v1 = va_arg(args, long);
                	long v2 = va_arg(args, long);
                	long v3 = va_arg(args, long);
                	va_end(args);
                	if (n < 2 || n > 4)
                		return errno = E2BIG, -1;
                	if (n <= 2 && v2 != 0)
                		return errno = EFAULT, -1;
                	if (n <= 3 && v3 != 0)
                		return errno = EFAULT, -1;
                	if (v0 != v1)
                		return errno = EINVAL, -1;
                	if (n > 2 && v0 != v2)
                		return errno = EINVAL, -1;
                	if (n > 3 && v0 != v3)
                		return errno = EINVAL, -1;
                	return 0;
                }
                
                static void loop();
                static int do_sandbox_none(void)
                {
                	loop();
                	return 0;
                }
                
                static long syz_execute_func(volatile long text)
                {
                	volatile long p[8] = {0};
                	(void)p;
                ((void (*)(void))(text))();
                	return 0;
                }
                
                struct thread_t {
                	int created, call;
                	event_t ready, done;
                };
                
                static struct thread_t threads[16];
                static void execute_call(int call);
                static int running;
                
                static void* thr(void* arg)
                {
                	struct thread_t* th = (struct thread_t*)arg;
                	for (;;) {
                		event_wait(&th->ready);
                		event_reset(&th->ready);
                		execute_call(th->call);
                		__atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
                		event_set(&th->done);
                	}
                	return 0;
                }
                
                static void execute_one(void)
                {
                	int i, call, thread;
                	for (call = 0; call < 16; call++) {
                		for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0])); thread++) {
                			struct thread_t* th = &threads[thread];
                			if (!th->created) {
                				th->created = 1;
                				event_init(&th->ready);
                				event_init(&th->done);
                				event_set(&th->done);
                				thread_start(thr, th);
                			}
                			if (!event_isset(&th->done))
                				continue;
                			event_reset(&th->done);
                			th->call = call;
                			__atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
                			event_set(&th->ready);
                			event_timedwait(&th->done, 45);
                			break;
                		}
                	}
                	for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
                		sleep_ms(1);
                }
                
                static void execute_one(void);
                
                #define WAIT_FLAGS 0
                
                static void loop(void)
                {
                	int iter;
                	for (iter = 0;; iter++) {
                		int pid = fork();
                		if (pid < 0)
                	exit(1);
                		if (pid == 0) {
                			execute_one();
                			exit(0);
                		}
                		int status = 0;
                		uint64_t start = current_time_ms();
                		for (;;) {
                			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
                				break;
                			sleep_ms(1);
                			if (current_time_ms() - start < 5 * 1000)
                				continue;
                			kill_and_wait(pid, &status);
                			break;
                		}
                	}
                }
                
                #ifndef SYS_foo
                #define SYS_foo 0
                #endif
                #ifndef SYS_mutate_buffer
                #define SYS_mutate_buffer 0
                #endif
                #ifndef SYS_test
                #define SYS_test 0
                #endif
                #ifndef SYS_test_length15
                #define SYS_test_length15 0
                #endif
                
                void execute_call(int call)
                {
                		switch (call) {
                	case 0:
                *(uint8_t*)0x20000000 = -1;
                		syscall(SYS_test, 0x20000000, 0, 0, 0, 0, 0);
                		break;
                	case 1:
                		syscall(SYS_mutate_buffer, 0x20000040);
                		break;
                	case 2:
                STORE_BY_BITMASK(uint16_t, , 0x20000140, 0, 0, 10);
                *(uint64_t*)0x20000148 = 0x10001;
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 2, 0, 5);
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 0x2b, 5, 6);
                STORE_BY_BITMASK(uint32_t, , 0x20000150, 0x42, 11, 15);
                STORE_BY_BITMASK(uint16_t, , 0x20000154, 0x20, 0, 11);
                STORE_BY_BITMASK(uint16_t, htobe16, 0x20000156, 0x20, 0, 11);
                *(uint8_t*)0x20000158 = 0x1f;
                		syscall(SYS_test, 0x20000140, 0, 0, 0, 0, 0);
                		break;
                	case 3:
                memcpy((void*)0x20000180, "\xde\x8d\x31\x22\x1e\x44\x3c\xba\x34\x4f\x81\xdc\x15\x34\xbf\x80\x15\xa1\x35\x04\x11\xce\x20\x07\xd2\x4f\xf1\x8a\xb5\x72\x19\x9e\x08\x9d\x69\x83\x91\x9b\xba\x8d\xd6\x29\x33\x4b\x17\x73\xd9\x5a\xee\xe8", 50);
                		syz_execute_func(0x20000180);
                		break;
                	case 4:
                memcpy((void*)0x200001c0, "\x66\xb9\x80\x00\x00\xc0\x0f\x32\x66\x35\x00\x01\x00\x00\x0f\x30\xdd\x63\x00\x62\x31\x0f\x30\x66\x0f\x3a\x0a\x17\x9c\x36\x2e\xf2\x6f\x69\x1d\xad\x46\xba\x41\x00\xb8\x8b\x00\xef\x0f\x08\xf3\x3e\x81\x77\x09\xec\x00", 53);
                		syscall(SYS_test, 0x200001c0, 0x35, 0, 0, 0, 0);
                		break;
                	case 5:
                sprintf((char*)0x20000200, "%020llu", (long long)7);
                		syscall(SYS_foo, 0x20000200, 0);
                		break;
                	case 6:
                		syscall(SYS_foo, 0x20000240, 0x20000280);
                		break;
                	case 7:
                *(uint8_t*)0x200002c0 = -1;
                		syscall(SYS_test, 0x200002c0, 0, 0, 0, 0, 0);
                		break;
                	case 8:
                *(uint8_t*)0x20000300 = 0x17;
                		syscall(SYS_test, 0x20000300, 0, 0, 0, 0, 0);
                		break;
                	case 9:
                		syscall(SYS_test_length15, 4, 2);
                		break;
                	case 10:
                memcpy((void*)0x20000000, "\000", 1);
                *(uint16_t*)0x20000040 = 0x401;
                *(uint32_t*)0x20000044 = 4;
                *(uint8_t*)0x20000048 = 6;
                *(uint16_t*)0x2000004a = 0xfffc;
                *(uint64_t*)0x20000050 = 3;
                		syz_compare(0x20000000, 1, 0x20000040, 0x18);
                		break;
                	case 11:
                		syz_compare_int(2, 2, 0x81, 0, 0);
                		break;
                	case 12:
                		syz_errno(0xf4);
                		break;
                	case 13:
                memcpy((void*)0x20000080, "\x94\x22\x18\xbe\x6a\x28\xed\xc5\xcd\x9d\xd7\x9f\x08\x4d\xc2\x39\x5e\xc1\xde\x75\xc5\x37\x24\x05\x55\x03\x25\x66\xd4\x2e\x5e\x83\xd0\x74\x32\xc4\x82\xb4\xec\x4a\x1e\x6e\xd5\x99\xf7\xac\xf6\xe8\xa6\xdf", 50);
                		syz_execute_func(0x20000080);
                		break;
                	case 14:
                		syz_exit(0x100);
                		break;
                	case 15:
                		syz_mmap(0x20ffb000, 0x2000);
                		break;
                	}
                
                }
                int main(void)
                {
                		syz_mmap(0x20000000, 0x1000000);
                			do_sandbox_none();
                	return 0;
                }
                
                In file included from /usr/include/bits/errno.h:26,
                                 from /usr/include/errno.h:28,
                                 from <stdin>:6:
                /usr/include/linux/errno.h:1:10: fatal error: asm/errno.h: No such file or directory
                    1 | #include <asm/errno.h>
                      |          ^~~~~~~~~~~~~
                compilation terminated.
                
                compiler invocation: gcc [-o /tmp/syz-executor207518362 -DGOOS_test=1 -DGOARCH_32_fork_shmem=1 -DHOSTGOOS_linux=1 -x c - -m32 -static -O2 -pthread -Wall -Werror -Wparentheses -Wunused-const-variable -Wframe-larger-than=16384 -Wno-overflow]
        --- FAIL: TestGenerate/test/32_fork_shmem/5 (0.05s)
            csource_test.go:122: opts: {Threaded:true Collide:false Repeat:true RepeatTimes:0 Procs:1 Sandbox:none Fault:false FaultCall:0 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false USB:false UseTmpDir:true HandleSegv:false Repro:false Trace:false}
                program:
                test$type_confusion1(&(0x7f0000000000)=@f1=0xff)
                mutate_buffer(&(0x7f0000000040)=""/237)
                test$bf0(&(0x7f0000000140)={0x0, 0x10001, 0x2, 0x2b, 0x42, 0x20, 0x20, 0x1f})
                syz_execute_func(&(0x7f0000000180)="de8d31221e443cba344f81dc1534bf8015a1350411ce2007d24ff18ab572199e089d6983919bba8dd629334b1773d95aeee8")
                test$text_x86_16(&(0x7f00000001c0)="66b9800000c00f326635000100000f30dd630062310f30660f3a0a179c362ef26f691dad46ba4100b88b00ef0f08f33e817709ec00", 0x35)
                foo$fmt0(&(0x7f0000000200)=0x7)
                foo$anyres(&(0x7f0000000240), &(0x7f0000000280))
                test$excessive_fields1(&(0x7f00000002c0)={0xff})
                test$excessive_fields1(&(0x7f0000000300)={0x17})
                test_length15(0x4, 0x2)
                syz_compare(&(0x7f0000000000)='\x00', 0x1, &(0x7f0000000040)=@align0={0x401, 0x4, 0x6, 0xfffc, 0x3}, 0x18)
                syz_compare_int$2(0x2, 0x2, 0x81)
                syz_errno(0xf4)
                syz_execute_func(&(0x7f0000000080)="942218be6a28edc5cd9dd79f084dc2395ec1de75c537240555032566d42e5e83d07432c482b4ec4a1e6ed599f7acf6e8a6df")
                syz_exit(0x100)
                syz_mmap(&(0x7f0000ffb000/0x2000)=nil, 0x2000)
                
            csource_test.go:123: failed to build program:
                // autogenerated by syzkaller (https://github.com/google/syzkaller)
                
                #define _GNU_SOURCE 
                
                #include <dirent.h>
                #include <endian.h>
                #include <errno.h>
                #include <pthread.h>
                #include <signal.h>
                #include <stdarg.h>
                #include <stdint.h>
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <sys/mman.h>
                #include <sys/stat.h>
                #include <sys/types.h>
                #include <sys/wait.h>
                #include <time.h>
                #include <unistd.h>
                
                static void kill_and_wait(int pid, int* status)
                {
                	kill(pid, SIGKILL);
                	while (waitpid(-1, status, 0) != pid) {
                	}
                }
                
                static void sleep_ms(uint64_t ms)
                {
                	usleep(ms * 1000);
                }
                
                static uint64_t current_time_ms(void)
                {
                	struct timespec ts;
                	if (clock_gettime(CLOCK_MONOTONIC, &ts))
                	exit(1);
                	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
                }
                
                static void use_temporary_dir(void)
                {
                	char tmpdir_template[] = "./syzkaller.XXXXXX";
                	char* tmpdir = mkdtemp(tmpdir_template);
                	if (!tmpdir)
                	exit(1);
                	if (chmod(tmpdir, 0777))
                	exit(1);
                	if (chdir(tmpdir))
                	exit(1);
                }
                
                static void remove_dir(const char* dir)
                {
                	DIR* dp;
                	struct dirent* ep;
                	dp = opendir(dir);
                	if (dp == NULL)
                	exit(1);
                	while ((ep = readdir(dp))) {
                		if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
                			continue;
                		char filename[FILENAME_MAX];
                		snprintf(filename, sizeof(filename), "%s/%s", dir, ep->d_name);
                		struct stat st;
                		if (lstat(filename, &st))
                	exit(1);
                		if (S_ISDIR(st.st_mode)) {
                			remove_dir(filename);
                			continue;
                		}
                		if (unlink(filename))
                	exit(1);
                	}
                	closedir(dp);
                	if (rmdir(dir))
                	exit(1);
                }
                
                static void thread_start(void* (*fn)(void*), void* arg)
                {
                	pthread_t th;
                	pthread_attr_t attr;
                	pthread_attr_init(&attr);
                	pthread_attr_setstacksize(&attr, 128 << 10);
                	int i;
                	for (i = 0; i < 100; i++) {
                		if (pthread_create(&th, &attr, fn, arg) == 0) {
                			pthread_attr_destroy(&attr);
                			return;
                		}
                		if (errno == EAGAIN) {
                			usleep(50);
                			continue;
                		}
                		break;
                	}
                	exit(1);
                }
                
                typedef struct {
                	pthread_mutex_t mu;
                	pthread_cond_t cv;
                	int state;
                } event_t;
                
                static void event_init(event_t* ev)
                {
                	if (pthread_mutex_init(&ev->mu, 0))
                	exit(1);
                	if (pthread_cond_init(&ev->cv, 0))
                	exit(1);
                	ev->state = 0;
                }
                
                static void event_reset(event_t* ev)
                {
                	ev->state = 0;
                }
                
                static void event_set(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	if (ev->state)
                	exit(1);
                	ev->state = 1;
                	pthread_mutex_unlock(&ev->mu);
                	pthread_cond_broadcast(&ev->cv);
                }
                
                static void event_wait(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	while (!ev->state)
                		pthread_cond_wait(&ev->cv, &ev->mu);
                	pthread_mutex_unlock(&ev->mu);
                }
                
                static int event_isset(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                static int event_timedwait(event_t* ev, uint64_t timeout)
                {
                	uint64_t start = current_time_ms();
                	uint64_t now = start;
                	pthread_mutex_lock(&ev->mu);
                	for (;;) {
                		if (ev->state)
                			break;
                		uint64_t remain = timeout - (now - start);
                		struct timespec ts;
                		ts.tv_sec = remain / 1000;
                		ts.tv_nsec = (remain % 1000) * 1000 * 1000;
                		pthread_cond_timedwait(&ev->cv, &ev->mu, &ts);
                		now = current_time_ms();
                		if (now - start > timeout)
                			break;
                	}
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                #define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
                #define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))
                
                static long syz_mmap(volatile long a0, volatile long a1)
                {
                	return (long)mmap((void*)a0, a1, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0);
                }
                
                static long syz_errno(volatile long v)
                {
                	errno = v;
                	return v == 0 ? 0 : -1;
                }
                
                static long syz_exit(volatile long status)
                {
                	_exit(status);
                	return 0;
                }
                
                static long syz_compare(volatile long want, volatile long want_len, volatile long got, volatile long got_len)
                {
                	if (want_len != got_len) {
                		errno = EBADF;
                		goto error;
                	}
                	if (memcmp((void*)want, (void*)got, want_len)) {
                		errno = EINVAL;
                		goto error;
                	}
                	return 0;
                
                error:
                	return -1;
                }
                
                static long syz_compare_int(volatile long n, ...)
                {
                	va_list args;
                	va_start(args, n);
                	long v0 = va_arg(args, long);
                	long v1 = va_arg(args, long);
                	long v2 = va_arg(args, long);
                	long v3 = va_arg(args, long);
                	va_end(args);
                	if (n < 2 || n > 4)
                		return errno = E2BIG, -1;
                	if (n <= 2 && v2 != 0)
                		return errno = EFAULT, -1;
                	if (n <= 3 && v3 != 0)
                		return errno = EFAULT, -1;
                	if (v0 != v1)
                		return errno = EINVAL, -1;
                	if (n > 2 && v0 != v2)
                		return errno = EINVAL, -1;
                	if (n > 3 && v0 != v3)
                		return errno = EINVAL, -1;
                	return 0;
                }
                
                static void loop();
                static int do_sandbox_none(void)
                {
                	loop();
                	return 0;
                }
                
                static long syz_execute_func(volatile long text)
                {
                	volatile long p[8] = {0};
                	(void)p;
                ((void (*)(void))(text))();
                	return 0;
                }
                
                struct thread_t {
                	int created, call;
                	event_t ready, done;
                };
                
                static struct thread_t threads[16];
                static void execute_call(int call);
                static int running;
                
                static void* thr(void* arg)
                {
                	struct thread_t* th = (struct thread_t*)arg;
                	for (;;) {
                		event_wait(&th->ready);
                		event_reset(&th->ready);
                		execute_call(th->call);
                		__atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
                		event_set(&th->done);
                	}
                	return 0;
                }
                
                static void execute_one(void)
                {
                	int i, call, thread;
                	for (call = 0; call < 16; call++) {
                		for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0])); thread++) {
                			struct thread_t* th = &threads[thread];
                			if (!th->created) {
                				th->created = 1;
                				event_init(&th->ready);
                				event_init(&th->done);
                				event_set(&th->done);
                				thread_start(thr, th);
                			}
                			if (!event_isset(&th->done))
                				continue;
                			event_reset(&th->done);
                			th->call = call;
                			__atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
                			event_set(&th->ready);
                			event_timedwait(&th->done, 45);
                			break;
                		}
                	}
                	for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
                		sleep_ms(1);
                }
                
                static void execute_one(void);
                
                #define WAIT_FLAGS 0
                
                static void loop(void)
                {
                	int iter;
                	for (iter = 0;; iter++) {
                		char cwdbuf[32];
                		sprintf(cwdbuf, "./%d", iter);
                		if (mkdir(cwdbuf, 0777))
                	exit(1);
                		int pid = fork();
                		if (pid < 0)
                	exit(1);
                		if (pid == 0) {
                			if (chdir(cwdbuf))
                	exit(1);
                			execute_one();
                			exit(0);
                		}
                		int status = 0;
                		uint64_t start = current_time_ms();
                		for (;;) {
                			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
                				break;
                			sleep_ms(1);
                			if (current_time_ms() - start < 5 * 1000)
                				continue;
                			kill_and_wait(pid, &status);
                			break;
                		}
                		remove_dir(cwdbuf);
                	}
                }
                
                #ifndef SYS_foo
                #define SYS_foo 0
                #endif
                #ifndef SYS_mutate_buffer
                #define SYS_mutate_buffer 0
                #endif
                #ifndef SYS_test
                #define SYS_test 0
                #endif
                #ifndef SYS_test_length15
                #define SYS_test_length15 0
                #endif
                
                void execute_call(int call)
                {
                		switch (call) {
                	case 0:
                *(uint8_t*)0x20000000 = -1;
                		syscall(SYS_test, 0x20000000, 0, 0, 0, 0, 0);
                		break;
                	case 1:
                		syscall(SYS_mutate_buffer, 0x20000040);
                		break;
                	case 2:
                STORE_BY_BITMASK(uint16_t, , 0x20000140, 0, 0, 10);
                *(uint64_t*)0x20000148 = 0x10001;
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 2, 0, 5);
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 0x2b, 5, 6);
                STORE_BY_BITMASK(uint32_t, , 0x20000150, 0x42, 11, 15);
                STORE_BY_BITMASK(uint16_t, , 0x20000154, 0x20, 0, 11);
                STORE_BY_BITMASK(uint16_t, htobe16, 0x20000156, 0x20, 0, 11);
                *(uint8_t*)0x20000158 = 0x1f;
                		syscall(SYS_test, 0x20000140, 0, 0, 0, 0, 0);
                		break;
                	case 3:
                memcpy((void*)0x20000180, "\xde\x8d\x31\x22\x1e\x44\x3c\xba\x34\x4f\x81\xdc\x15\x34\xbf\x80\x15\xa1\x35\x04\x11\xce\x20\x07\xd2\x4f\xf1\x8a\xb5\x72\x19\x9e\x08\x9d\x69\x83\x91\x9b\xba\x8d\xd6\x29\x33\x4b\x17\x73\xd9\x5a\xee\xe8", 50);
                		syz_execute_func(0x20000180);
                		break;
                	case 4:
                memcpy((void*)0x200001c0, "\x66\xb9\x80\x00\x00\xc0\x0f\x32\x66\x35\x00\x01\x00\x00\x0f\x30\xdd\x63\x00\x62\x31\x0f\x30\x66\x0f\x3a\x0a\x17\x9c\x36\x2e\xf2\x6f\x69\x1d\xad\x46\xba\x41\x00\xb8\x8b\x00\xef\x0f\x08\xf3\x3e\x81\x77\x09\xec\x00", 53);
                		syscall(SYS_test, 0x200001c0, 0x35, 0, 0, 0, 0);
                		break;
                	case 5:
                sprintf((char*)0x20000200, "%020llu", (long long)7);
                		syscall(SYS_foo, 0x20000200, 0);
                		break;
                	case 6:
                		syscall(SYS_foo, 0x20000240, 0x20000280);
                		break;
                	case 7:
                *(uint8_t*)0x200002c0 = -1;
                		syscall(SYS_test, 0x200002c0, 0, 0, 0, 0, 0);
                		break;
                	case 8:
                *(uint8_t*)0x20000300 = 0x17;
                		syscall(SYS_test, 0x20000300, 0, 0, 0, 0, 0);
                		break;
                	case 9:
                		syscall(SYS_test_length15, 4, 2);
                		break;
                	case 10:
                memcpy((void*)0x20000000, "\000", 1);
                *(uint16_t*)0x20000040 = 0x401;
                *(uint32_t*)0x20000044 = 4;
                *(uint8_t*)0x20000048 = 6;
                *(uint16_t*)0x2000004a = 0xfffc;
                *(uint64_t*)0x20000050 = 3;
                		syz_compare(0x20000000, 1, 0x20000040, 0x18);
                		break;
                	case 11:
                		syz_compare_int(2, 2, 0x81, 0, 0);
                		break;
                	case 12:
                		syz_errno(0xf4);
                		break;
                	case 13:
                memcpy((void*)0x20000080, "\x94\x22\x18\xbe\x6a\x28\xed\xc5\xcd\x9d\xd7\x9f\x08\x4d\xc2\x39\x5e\xc1\xde\x75\xc5\x37\x24\x05\x55\x03\x25\x66\xd4\x2e\x5e\x83\xd0\x74\x32\xc4\x82\xb4\xec\x4a\x1e\x6e\xd5\x99\xf7\xac\xf6\xe8\xa6\xdf", 50);
                		syz_execute_func(0x20000080);
                		break;
                	case 14:
                		syz_exit(0x100);
                		break;
                	case 15:
                		syz_mmap(0x20ffb000, 0x2000);
                		break;
                	}
                
                }
                int main(void)
                {
                		syz_mmap(0x20000000, 0x1000000);
                			use_temporary_dir();
                			do_sandbox_none();
                	return 0;
                }
                
                In file included from /usr/include/bits/errno.h:26,
                                 from /usr/include/errno.h:28,
                                 from <stdin>:7:
                /usr/include/linux/errno.h:1:10: fatal error: asm/errno.h: No such file or directory
                    1 | #include <asm/errno.h>
                      |          ^~~~~~~~~~~~~
                compilation terminated.
                
                compiler invocation: gcc [-o /tmp/syz-executor451702189 -DGOOS_test=1 -DGOARCH_32_fork_shmem=1 -DHOSTGOOS_linux=1 -x c - -m32 -static -O2 -pthread -Wall -Werror -Wparentheses -Wunused-const-variable -Wframe-larger-than=16384 -Wno-overflow]
        --- FAIL: TestGenerate/test/32_fork_shmem/12 (0.06s)
            csource_test.go:122: opts: {Threaded:true Collide:true Repeat:true RepeatTimes:0 Procs:2 Sandbox:none Fault:false FaultCall:0 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false USB:false UseTmpDir:true HandleSegv:false Repro:true Trace:false}
                program:
                test$type_confusion1(&(0x7f0000000000)=@f1=0xff)
                mutate_buffer(&(0x7f0000000040)=""/237)
                test$bf0(&(0x7f0000000140)={0x0, 0x10001, 0x2, 0x2b, 0x42, 0x20, 0x20, 0x1f})
                syz_execute_func(&(0x7f0000000180)="de8d31221e443cba344f81dc1534bf8015a1350411ce2007d24ff18ab572199e089d6983919bba8dd629334b1773d95aeee8")
                test$text_x86_16(&(0x7f00000001c0)="66b9800000c00f326635000100000f30dd630062310f30660f3a0a179c362ef26f691dad46ba4100b88b00ef0f08f33e817709ec00", 0x35)
                foo$fmt0(&(0x7f0000000200)=0x7)
                foo$anyres(&(0x7f0000000240), &(0x7f0000000280))
                test$excessive_fields1(&(0x7f00000002c0)={0xff})
                test$excessive_fields1(&(0x7f0000000300)={0x17})
                test_length15(0x4, 0x2)
                syz_compare(&(0x7f0000000000)='\x00', 0x1, &(0x7f0000000040)=@align0={0x401, 0x4, 0x6, 0xfffc, 0x3}, 0x18)
                syz_compare_int$2(0x2, 0x2, 0x81)
                syz_errno(0xf4)
                syz_execute_func(&(0x7f0000000080)="942218be6a28edc5cd9dd79f084dc2395ec1de75c537240555032566d42e5e83d07432c482b4ec4a1e6ed599f7acf6e8a6df")
                syz_exit(0x100)
                syz_mmap(&(0x7f0000ffb000/0x2000)=nil, 0x2000)
                
            csource_test.go:123: failed to build program:
                // autogenerated by syzkaller (https://github.com/google/syzkaller)
                
                #define _GNU_SOURCE 
                
                #include <dirent.h>
                #include <endian.h>
                #include <errno.h>
                #include <pthread.h>
                #include <signal.h>
                #include <stdarg.h>
                #include <stdint.h>
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <sys/mman.h>
                #include <sys/stat.h>
                #include <sys/types.h>
                #include <sys/wait.h>
                #include <time.h>
                #include <unistd.h>
                
                static unsigned long long procid;
                
                static void kill_and_wait(int pid, int* status)
                {
                	kill(pid, SIGKILL);
                	while (waitpid(-1, status, 0) != pid) {
                	}
                }
                
                static void sleep_ms(uint64_t ms)
                {
                	usleep(ms * 1000);
                }
                
                static uint64_t current_time_ms(void)
                {
                	struct timespec ts;
                	if (clock_gettime(CLOCK_MONOTONIC, &ts))
                	exit(1);
                	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
                }
                
                static void use_temporary_dir(void)
                {
                	char tmpdir_template[] = "./syzkaller.XXXXXX";
                	char* tmpdir = mkdtemp(tmpdir_template);
                	if (!tmpdir)
                	exit(1);
                	if (chmod(tmpdir, 0777))
                	exit(1);
                	if (chdir(tmpdir))
                	exit(1);
                }
                
                static void remove_dir(const char* dir)
                {
                	DIR* dp;
                	struct dirent* ep;
                	dp = opendir(dir);
                	if (dp == NULL)
                	exit(1);
                	while ((ep = readdir(dp))) {
                		if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
                			continue;
                		char filename[FILENAME_MAX];
                		snprintf(filename, sizeof(filename), "%s/%s", dir, ep->d_name);
                		struct stat st;
                		if (lstat(filename, &st))
                	exit(1);
                		if (S_ISDIR(st.st_mode)) {
                			remove_dir(filename);
                			continue;
                		}
                		if (unlink(filename))
                	exit(1);
                	}
                	closedir(dp);
                	if (rmdir(dir))
                	exit(1);
                }
                
                static void thread_start(void* (*fn)(void*), void* arg)
                {
                	pthread_t th;
                	pthread_attr_t attr;
                	pthread_attr_init(&attr);
                	pthread_attr_setstacksize(&attr, 128 << 10);
                	int i;
                	for (i = 0; i < 100; i++) {
                		if (pthread_create(&th, &attr, fn, arg) == 0) {
                			pthread_attr_destroy(&attr);
                			return;
                		}
                		if (errno == EAGAIN) {
                			usleep(50);
                			continue;
                		}
                		break;
                	}
                	exit(1);
                }
                
                typedef struct {
                	pthread_mutex_t mu;
                	pthread_cond_t cv;
                	int state;
                } event_t;
                
                static void event_init(event_t* ev)
                {
                	if (pthread_mutex_init(&ev->mu, 0))
                	exit(1);
                	if (pthread_cond_init(&ev->cv, 0))
                	exit(1);
                	ev->state = 0;
                }
                
                static void event_reset(event_t* ev)
                {
                	ev->state = 0;
                }
                
                static void event_set(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	if (ev->state)
                	exit(1);
                	ev->state = 1;
                	pthread_mutex_unlock(&ev->mu);
                	pthread_cond_broadcast(&ev->cv);
                }
                
                static void event_wait(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	while (!ev->state)
                		pthread_cond_wait(&ev->cv, &ev->mu);
                	pthread_mutex_unlock(&ev->mu);
                }
                
                static int event_isset(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                static int event_timedwait(event_t* ev, uint64_t timeout)
                {
                	uint64_t start = current_time_ms();
                	uint64_t now = start;
                	pthread_mutex_lock(&ev->mu);
                	for (;;) {
                		if (ev->state)
                			break;
                		uint64_t remain = timeout - (now - start);
                		struct timespec ts;
                		ts.tv_sec = remain / 1000;
                		ts.tv_nsec = (remain % 1000) * 1000 * 1000;
                		pthread_cond_timedwait(&ev->cv, &ev->mu, &ts);
                		now = current_time_ms();
                		if (now - start > timeout)
                			break;
                	}
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                #define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
                #define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))
                
                static long syz_mmap(volatile long a0, volatile long a1)
                {
                	return (long)mmap((void*)a0, a1, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0);
                }
                
                static long syz_errno(volatile long v)
                {
                	errno = v;
                	return v == 0 ? 0 : -1;
                }
                
                static long syz_exit(volatile long status)
                {
                	_exit(status);
                	return 0;
                }
                
                static long syz_compare(volatile long want, volatile long want_len, volatile long got, volatile long got_len)
                {
                	if (want_len != got_len) {
                		errno = EBADF;
                		goto error;
                	}
                	if (memcmp((void*)want, (void*)got, want_len)) {
                		errno = EINVAL;
                		goto error;
                	}
                	return 0;
                
                error:
                	return -1;
                }
                
                static long syz_compare_int(volatile long n, ...)
                {
                	va_list args;
                	va_start(args, n);
                	long v0 = va_arg(args, long);
                	long v1 = va_arg(args, long);
                	long v2 = va_arg(args, long);
                	long v3 = va_arg(args, long);
                	va_end(args);
                	if (n < 2 || n > 4)
                		return errno = E2BIG, -1;
                	if (n <= 2 && v2 != 0)
                		return errno = EFAULT, -1;
                	if (n <= 3 && v3 != 0)
                		return errno = EFAULT, -1;
                	if (v0 != v1)
                		return errno = EINVAL, -1;
                	if (n > 2 && v0 != v2)
                		return errno = EINVAL, -1;
                	if (n > 3 && v0 != v3)
                		return errno = EINVAL, -1;
                	return 0;
                }
                
                static void loop();
                static int do_sandbox_none(void)
                {
                	loop();
                	return 0;
                }
                
                static long syz_execute_func(volatile long text)
                {
                	volatile long p[8] = {0};
                	(void)p;
                ((void (*)(void))(text))();
                	return 0;
                }
                
                struct thread_t {
                	int created, call;
                	event_t ready, done;
                };
                
                static struct thread_t threads[16];
                static void execute_call(int call);
                static int running;
                
                static void* thr(void* arg)
                {
                	struct thread_t* th = (struct thread_t*)arg;
                	for (;;) {
                		event_wait(&th->ready);
                		event_reset(&th->ready);
                		execute_call(th->call);
                		__atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
                		event_set(&th->done);
                	}
                	return 0;
                }
                
                static void execute_one(void)
                {
                	if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {
                	}
                	int i, call, thread;
                	int collide = 0;
                again:
                	for (call = 0; call < 16; call++) {
                		for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0])); thread++) {
                			struct thread_t* th = &threads[thread];
                			if (!th->created) {
                				th->created = 1;
                				event_init(&th->ready);
                				event_init(&th->done);
                				event_set(&th->done);
                				thread_start(thr, th);
                			}
                			if (!event_isset(&th->done))
                				continue;
                			event_reset(&th->done);
                			th->call = call;
                			__atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
                			event_set(&th->ready);
                			if (collide && (call % 2) == 0)
                				break;
                			event_timedwait(&th->done, 45);
                			break;
                		}
                	}
                	for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
                		sleep_ms(1);
                	if (!collide) {
                		collide = 1;
                		goto again;
                	}
                }
                
                static void execute_one(void);
                
                #define WAIT_FLAGS 0
                
                static void loop(void)
                {
                	int iter;
                	for (iter = 0;; iter++) {
                		char cwdbuf[32];
                		sprintf(cwdbuf, "./%d", iter);
                		if (mkdir(cwdbuf, 0777))
                	exit(1);
                		int pid = fork();
                		if (pid < 0)
                	exit(1);
                		if (pid == 0) {
                			if (chdir(cwdbuf))
                	exit(1);
                			execute_one();
                			exit(0);
                		}
                		int status = 0;
                		uint64_t start = current_time_ms();
                		for (;;) {
                			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
                				break;
                			sleep_ms(1);
                			if (current_time_ms() - start < 5 * 1000)
                				continue;
                			kill_and_wait(pid, &status);
                			break;
                		}
                		remove_dir(cwdbuf);
                	}
                }
                
                #ifndef SYS_foo
                #define SYS_foo 0
                #endif
                #ifndef SYS_mutate_buffer
                #define SYS_mutate_buffer 0
                #endif
                #ifndef SYS_test
                #define SYS_test 0
                #endif
                #ifndef SYS_test_length15
                #define SYS_test_length15 0
                #endif
                
                void execute_call(int call)
                {
                		switch (call) {
                	case 0:
                *(uint8_t*)0x20000000 = -1;
                		syscall(SYS_test, 0x20000000, 0, 0, 0, 0, 0);
                		break;
                	case 1:
                		syscall(SYS_mutate_buffer, 0x20000040);
                		break;
                	case 2:
                STORE_BY_BITMASK(uint16_t, , 0x20000140, 0, 0, 10);
                *(uint64_t*)0x20000148 = 0x10001;
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 2, 0, 5);
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 0x2b, 5, 6);
                STORE_BY_BITMASK(uint32_t, , 0x20000150, 0x42, 11, 15);
                STORE_BY_BITMASK(uint16_t, , 0x20000154, 0x20, 0, 11);
                STORE_BY_BITMASK(uint16_t, htobe16, 0x20000156, 0x20, 0, 11);
                *(uint8_t*)0x20000158 = 0x1f;
                		syscall(SYS_test, 0x20000140, 0, 0, 0, 0, 0);
                		break;
                	case 3:
                memcpy((void*)0x20000180, "\xde\x8d\x31\x22\x1e\x44\x3c\xba\x34\x4f\x81\xdc\x15\x34\xbf\x80\x15\xa1\x35\x04\x11\xce\x20\x07\xd2\x4f\xf1\x8a\xb5\x72\x19\x9e\x08\x9d\x69\x83\x91\x9b\xba\x8d\xd6\x29\x33\x4b\x17\x73\xd9\x5a\xee\xe8", 50);
                		syz_execute_func(0x20000180);
                		break;
                	case 4:
                memcpy((void*)0x200001c0, "\x66\xb9\x80\x00\x00\xc0\x0f\x32\x66\x35\x00\x01\x00\x00\x0f\x30\xdd\x63\x00\x62\x31\x0f\x30\x66\x0f\x3a\x0a\x17\x9c\x36\x2e\xf2\x6f\x69\x1d\xad\x46\xba\x41\x00\xb8\x8b\x00\xef\x0f\x08\xf3\x3e\x81\x77\x09\xec\x00", 53);
                		syscall(SYS_test, 0x200001c0, 0x35, 0, 0, 0, 0);
                		break;
                	case 5:
                sprintf((char*)0x20000200, "%020llu", (long long)7);
                		syscall(SYS_foo, 0x20000200, 0);
                		break;
                	case 6:
                		syscall(SYS_foo, 0x20000240, 0x20000280);
                		break;
                	case 7:
                *(uint8_t*)0x200002c0 = -1;
                		syscall(SYS_test, 0x200002c0, 0, 0, 0, 0, 0);
                		break;
                	case 8:
                *(uint8_t*)0x20000300 = 0x17;
                		syscall(SYS_test, 0x20000300, 0, 0, 0, 0, 0);
                		break;
                	case 9:
                		syscall(SYS_test_length15, 4, 2);
                		break;
                	case 10:
                memcpy((void*)0x20000000, "\000", 1);
                *(uint16_t*)0x20000040 = 0x401;
                *(uint32_t*)0x20000044 = 4;
                *(uint8_t*)0x20000048 = 6;
                *(uint16_t*)0x2000004a = 0xfffc;
                *(uint64_t*)0x20000050 = 3;
                		syz_compare(0x20000000, 1, 0x20000040, 0x18);
                		break;
                	case 11:
                		syz_compare_int(2, 2, 0x81, 0, 0);
                		break;
                	case 12:
                		syz_errno(0xf4);
                		break;
                	case 13:
                memcpy((void*)0x20000080, "\x94\x22\x18\xbe\x6a\x28\xed\xc5\xcd\x9d\xd7\x9f\x08\x4d\xc2\x39\x5e\xc1\xde\x75\xc5\x37\x24\x05\x55\x03\x25\x66\xd4\x2e\x5e\x83\xd0\x74\x32\xc4\x82\xb4\xec\x4a\x1e\x6e\xd5\x99\xf7\xac\xf6\xe8\xa6\xdf", 50);
                		syz_execute_func(0x20000080);
                		break;
                	case 14:
                		syz_exit(0x100);
                		break;
                	case 15:
                		syz_mmap(0x20ffb000, 0x2000);
                		break;
                	}
                
                }
                int main(void)
                {
                		syz_mmap(0x20000000, 0x1000000);
                	for (procid = 0; procid < 2; procid++) {
                		if (fork() == 0) {
                			use_temporary_dir();
                			do_sandbox_none();
                		}
                	}
                	sleep(1000000);
                	return 0;
                }
                
                In file included from /usr/include/bits/errno.h:26,
                                 from /usr/include/errno.h:28,
                                 from <stdin>:7:
                /usr/include/linux/errno.h:1:10: fatal error: asm/errno.h: No such file or directory
                    1 | #include <asm/errno.h>
                      |          ^~~~~~~~~~~~~
                compilation terminated.
                
                compiler invocation: gcc [-o /tmp/syz-executor184339047 -DGOOS_test=1 -DGOARCH_32_fork_shmem=1 -DHOSTGOOS_linux=1 -x c - -m32 -static -O2 -pthread -Wall -Werror -Wparentheses -Wunused-const-variable -Wframe-larger-than=16384 -Wno-overflow]
        --- FAIL: TestGenerate/test/32_fork_shmem/2 (0.07s)
            csource_test.go:122: opts: {Threaded:true Collide:true Repeat:true RepeatTimes:0 Procs:0 Sandbox:none Fault:false FaultCall:0 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false USB:false UseTmpDir:true HandleSegv:false Repro:false Trace:false}
                program:
                test$type_confusion1(&(0x7f0000000000)=@f1=0xff)
                mutate_buffer(&(0x7f0000000040)=""/237)
                test$bf0(&(0x7f0000000140)={0x0, 0x10001, 0x2, 0x2b, 0x42, 0x20, 0x20, 0x1f})
                syz_execute_func(&(0x7f0000000180)="de8d31221e443cba344f81dc1534bf8015a1350411ce2007d24ff18ab572199e089d6983919bba8dd629334b1773d95aeee8")
                test$text_x86_16(&(0x7f00000001c0)="66b9800000c00f326635000100000f30dd630062310f30660f3a0a179c362ef26f691dad46ba4100b88b00ef0f08f33e817709ec00", 0x35)
                foo$fmt0(&(0x7f0000000200)=0x7)
                foo$anyres(&(0x7f0000000240), &(0x7f0000000280))
                test$excessive_fields1(&(0x7f00000002c0)={0xff})
                test$excessive_fields1(&(0x7f0000000300)={0x17})
                test_length15(0x4, 0x2)
                syz_compare(&(0x7f0000000000)='\x00', 0x1, &(0x7f0000000040)=@align0={0x401, 0x4, 0x6, 0xfffc, 0x3}, 0x18)
                syz_compare_int$2(0x2, 0x2, 0x81)
                syz_errno(0xf4)
                syz_execute_func(&(0x7f0000000080)="942218be6a28edc5cd9dd79f084dc2395ec1de75c537240555032566d42e5e83d07432c482b4ec4a1e6ed599f7acf6e8a6df")
                syz_exit(0x100)
                syz_mmap(&(0x7f0000ffb000/0x2000)=nil, 0x2000)
                
            csource_test.go:123: failed to build program:
                // autogenerated by syzkaller (https://github.com/google/syzkaller)
                
                #define _GNU_SOURCE 
                
                #include <dirent.h>
                #include <endian.h>
                #include <errno.h>
                #include <pthread.h>
                #include <signal.h>
                #include <stdarg.h>
                #include <stdint.h>
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <sys/mman.h>
                #include <sys/stat.h>
                #include <sys/types.h>
                #include <sys/wait.h>
                #include <time.h>
                #include <unistd.h>
                
                static void kill_and_wait(int pid, int* status)
                {
                	kill(pid, SIGKILL);
                	while (waitpid(-1, status, 0) != pid) {
                	}
                }
                
                static void sleep_ms(uint64_t ms)
                {
                	usleep(ms * 1000);
                }
                
                static uint64_t current_time_ms(void)
                {
                	struct timespec ts;
                	if (clock_gettime(CLOCK_MONOTONIC, &ts))
                	exit(1);
                	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
                }
                
                static void use_temporary_dir(void)
                {
                	char tmpdir_template[] = "./syzkaller.XXXXXX";
                	char* tmpdir = mkdtemp(tmpdir_template);
                	if (!tmpdir)
                	exit(1);
                	if (chmod(tmpdir, 0777))
                	exit(1);
                	if (chdir(tmpdir))
                	exit(1);
                }
                
                static void remove_dir(const char* dir)
                {
                	DIR* dp;
                	struct dirent* ep;
                	dp = opendir(dir);
                	if (dp == NULL)
                	exit(1);
                	while ((ep = readdir(dp))) {
                		if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
                			continue;
                		char filename[FILENAME_MAX];
                		snprintf(filename, sizeof(filename), "%s/%s", dir, ep->d_name);
                		struct stat st;
                		if (lstat(filename, &st))
                	exit(1);
                		if (S_ISDIR(st.st_mode)) {
                			remove_dir(filename);
                			continue;
                		}
                		if (unlink(filename))
                	exit(1);
                	}
                	closedir(dp);
                	if (rmdir(dir))
                	exit(1);
                }
                
                static void thread_start(void* (*fn)(void*), void* arg)
                {
                	pthread_t th;
                	pthread_attr_t attr;
                	pthread_attr_init(&attr);
                	pthread_attr_setstacksize(&attr, 128 << 10);
                	int i;
                	for (i = 0; i < 100; i++) {
                		if (pthread_create(&th, &attr, fn, arg) == 0) {
                			pthread_attr_destroy(&attr);
                			return;
                		}
                		if (errno == EAGAIN) {
                			usleep(50);
                			continue;
                		}
                		break;
                	}
                	exit(1);
                }
                
                typedef struct {
                	pthread_mutex_t mu;
                	pthread_cond_t cv;
                	int state;
                } event_t;
                
                static void event_init(event_t* ev)
                {
                	if (pthread_mutex_init(&ev->mu, 0))
                	exit(1);
                	if (pthread_cond_init(&ev->cv, 0))
                	exit(1);
                	ev->state = 0;
                }
                
                static void event_reset(event_t* ev)
                {
                	ev->state = 0;
                }
                
                static void event_set(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	if (ev->state)
                	exit(1);
                	ev->state = 1;
                	pthread_mutex_unlock(&ev->mu);
                	pthread_cond_broadcast(&ev->cv);
                }
                
                static void event_wait(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	while (!ev->state)
                		pthread_cond_wait(&ev->cv, &ev->mu);
                	pthread_mutex_unlock(&ev->mu);
                }
                
                static int event_isset(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                static int event_timedwait(event_t* ev, uint64_t timeout)
                {
                	uint64_t start = current_time_ms();
                	uint64_t now = start;
                	pthread_mutex_lock(&ev->mu);
                	for (;;) {
                		if (ev->state)
                			break;
                		uint64_t remain = timeout - (now - start);
                		struct timespec ts;
                		ts.tv_sec = remain / 1000;
                		ts.tv_nsec = (remain % 1000) * 1000 * 1000;
                		pthread_cond_timedwait(&ev->cv, &ev->mu, &ts);
                		now = current_time_ms();
                		if (now - start > timeout)
                			break;
                	}
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                #define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
                #define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))
                
                static long syz_mmap(volatile long a0, volatile long a1)
                {
                	return (long)mmap((void*)a0, a1, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0);
                }
                
                static long syz_errno(volatile long v)
                {
                	errno = v;
                	return v == 0 ? 0 : -1;
                }
                
                static long syz_exit(volatile long status)
                {
                	_exit(status);
                	return 0;
                }
                
                static long syz_compare(volatile long want, volatile long want_len, volatile long got, volatile long got_len)
                {
                	if (want_len != got_len) {
                		errno = EBADF;
                		goto error;
                	}
                	if (memcmp((void*)want, (void*)got, want_len)) {
                		errno = EINVAL;
                		goto error;
                	}
                	return 0;
                
                error:
                	return -1;
                }
                
                static long syz_compare_int(volatile long n, ...)
                {
                	va_list args;
                	va_start(args, n);
                	long v0 = va_arg(args, long);
                	long v1 = va_arg(args, long);
                	long v2 = va_arg(args, long);
                	long v3 = va_arg(args, long);
                	va_end(args);
                	if (n < 2 || n > 4)
                		return errno = E2BIG, -1;
                	if (n <= 2 && v2 != 0)
                		return errno = EFAULT, -1;
                	if (n <= 3 && v3 != 0)
                		return errno = EFAULT, -1;
                	if (v0 != v1)
                		return errno = EINVAL, -1;
                	if (n > 2 && v0 != v2)
                		return errno = EINVAL, -1;
                	if (n > 3 && v0 != v3)
                		return errno = EINVAL, -1;
                	return 0;
                }
                
                static void loop();
                static int do_sandbox_none(void)
                {
                	loop();
                	return 0;
                }
                
                static long syz_execute_func(volatile long text)
                {
                	volatile long p[8] = {0};
                	(void)p;
                ((void (*)(void))(text))();
                	return 0;
                }
                
                struct thread_t {
                	int created, call;
                	event_t ready, done;
                };
                
                static struct thread_t threads[16];
                static void execute_call(int call);
                static int running;
                
                static void* thr(void* arg)
                {
                	struct thread_t* th = (struct thread_t*)arg;
                	for (;;) {
                		event_wait(&th->ready);
                		event_reset(&th->ready);
                		execute_call(th->call);
                		__atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
                		event_set(&th->done);
                	}
                	return 0;
                }
                
                static void execute_one(void)
                {
                	int i, call, thread;
                	int collide = 0;
                again:
                	for (call = 0; call < 16; call++) {
                		for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0])); thread++) {
                			struct thread_t* th = &threads[thread];
                			if (!th->created) {
                				th->created = 1;
                				event_init(&th->ready);
                				event_init(&th->done);
                				event_set(&th->done);
                				thread_start(thr, th);
                			}
                			if (!event_isset(&th->done))
                				continue;
                			event_reset(&th->done);
                			th->call = call;
                			__atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
                			event_set(&th->ready);
                			if (collide && (call % 2) == 0)
                				break;
                			event_timedwait(&th->done, 45);
                			break;
                		}
                	}
                	for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
                		sleep_ms(1);
                	if (!collide) {
                		collide = 1;
                		goto again;
                	}
                }
                
                static void execute_one(void);
                
                #define WAIT_FLAGS 0
                
                static void loop(void)
                {
                	int iter;
                	for (iter = 0;; iter++) {
                		char cwdbuf[32];
                		sprintf(cwdbuf, "./%d", iter);
                		if (mkdir(cwdbuf, 0777))
                	exit(1);
                		int pid = fork();
                		if (pid < 0)
                	exit(1);
                		if (pid == 0) {
                			if (chdir(cwdbuf))
                	exit(1);
                			execute_one();
                			exit(0);
                		}
                		int status = 0;
                		uint64_t start = current_time_ms();
                		for (;;) {
                			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
                				break;
                			sleep_ms(1);
                			if (current_time_ms() - start < 5 * 1000)
                				continue;
                			kill_and_wait(pid, &status);
                			break;
                		}
                		remove_dir(cwdbuf);
                	}
                }
                
                #ifndef SYS_foo
                #define SYS_foo 0
                #endif
                #ifndef SYS_mutate_buffer
                #define SYS_mutate_buffer 0
                #endif
                #ifndef SYS_test
                #define SYS_test 0
                #endif
                #ifndef SYS_test_length15
                #define SYS_test_length15 0
                #endif
                
                void execute_call(int call)
                {
                		switch (call) {
                	case 0:
                *(uint8_t*)0x20000000 = -1;
                		syscall(SYS_test, 0x20000000, 0, 0, 0, 0, 0);
                		break;
                	case 1:
                		syscall(SYS_mutate_buffer, 0x20000040);
                		break;
                	case 2:
                STORE_BY_BITMASK(uint16_t, , 0x20000140, 0, 0, 10);
                *(uint64_t*)0x20000148 = 0x10001;
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 2, 0, 5);
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 0x2b, 5, 6);
                STORE_BY_BITMASK(uint32_t, , 0x20000150, 0x42, 11, 15);
                STORE_BY_BITMASK(uint16_t, , 0x20000154, 0x20, 0, 11);
                STORE_BY_BITMASK(uint16_t, htobe16, 0x20000156, 0x20, 0, 11);
                *(uint8_t*)0x20000158 = 0x1f;
                		syscall(SYS_test, 0x20000140, 0, 0, 0, 0, 0);
                		break;
                	case 3:
                memcpy((void*)0x20000180, "\xde\x8d\x31\x22\x1e\x44\x3c\xba\x34\x4f\x81\xdc\x15\x34\xbf\x80\x15\xa1\x35\x04\x11\xce\x20\x07\xd2\x4f\xf1\x8a\xb5\x72\x19\x9e\x08\x9d\x69\x83\x91\x9b\xba\x8d\xd6\x29\x33\x4b\x17\x73\xd9\x5a\xee\xe8", 50);
                		syz_execute_func(0x20000180);
                		break;
                	case 4:
                memcpy((void*)0x200001c0, "\x66\xb9\x80\x00\x00\xc0\x0f\x32\x66\x35\x00\x01\x00\x00\x0f\x30\xdd\x63\x00\x62\x31\x0f\x30\x66\x0f\x3a\x0a\x17\x9c\x36\x2e\xf2\x6f\x69\x1d\xad\x46\xba\x41\x00\xb8\x8b\x00\xef\x0f\x08\xf3\x3e\x81\x77\x09\xec\x00", 53);
                		syscall(SYS_test, 0x200001c0, 0x35, 0, 0, 0, 0);
                		break;
                	case 5:
                sprintf((char*)0x20000200, "%020llu", (long long)7);
                		syscall(SYS_foo, 0x20000200, 0);
                		break;
                	case 6:
                		syscall(SYS_foo, 0x20000240, 0x20000280);
                		break;
                	case 7:
                *(uint8_t*)0x200002c0 = -1;
                		syscall(SYS_test, 0x200002c0, 0, 0, 0, 0, 0);
                		break;
                	case 8:
                *(uint8_t*)0x20000300 = 0x17;
                		syscall(SYS_test, 0x20000300, 0, 0, 0, 0, 0);
                		break;
                	case 9:
                		syscall(SYS_test_length15, 4, 2);
                		break;
                	case 10:
                memcpy((void*)0x20000000, "\000", 1);
                *(uint16_t*)0x20000040 = 0x401;
                *(uint32_t*)0x20000044 = 4;
                *(uint8_t*)0x20000048 = 6;
                *(uint16_t*)0x2000004a = 0xfffc;
                *(uint64_t*)0x20000050 = 3;
                		syz_compare(0x20000000, 1, 0x20000040, 0x18);
                		break;
                	case 11:
                		syz_compare_int(2, 2, 0x81, 0, 0);
                		break;
                	case 12:
                		syz_errno(0xf4);
                		break;
                	case 13:
                memcpy((void*)0x20000080, "\x94\x22\x18\xbe\x6a\x28\xed\xc5\xcd\x9d\xd7\x9f\x08\x4d\xc2\x39\x5e\xc1\xde\x75\xc5\x37\x24\x05\x55\x03\x25\x66\xd4\x2e\x5e\x83\xd0\x74\x32\xc4\x82\xb4\xec\x4a\x1e\x6e\xd5\x99\xf7\xac\xf6\xe8\xa6\xdf", 50);
                		syz_execute_func(0x20000080);
                		break;
                	case 14:
                		syz_exit(0x100);
                		break;
                	case 15:
                		syz_mmap(0x20ffb000, 0x2000);
                		break;
                	}
                
                }
                int main(void)
                {
                		syz_mmap(0x20000000, 0x1000000);
                			use_temporary_dir();
                			do_sandbox_none();
                	return 0;
                }
                
                In file included from /usr/include/bits/errno.h:26,
                                 from /usr/include/errno.h:28,
                                 from <stdin>:7:
                /usr/include/linux/errno.h:1:10: fatal error: asm/errno.h: No such file or directory
                    1 | #include <asm/errno.h>
                      |          ^~~~~~~~~~~~~
                compilation terminated.
                
                compiler invocation: gcc [-o /tmp/syz-executor998392838 -DGOOS_test=1 -DGOARCH_32_fork_shmem=1 -DHOSTGOOS_linux=1 -x c - -m32 -static -O2 -pthread -Wall -Werror -Wparentheses -Wunused-const-variable -Wframe-larger-than=16384 -Wno-overflow]
        --- FAIL: TestGenerate/test/32_fork_shmem/7 (0.08s)
            csource_test.go:122: opts: {Threaded:true Collide:false Repeat:true RepeatTimes:0 Procs:0 Sandbox: Fault:false FaultCall:0 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false USB:false UseTmpDir:true HandleSegv:false Repro:false Trace:false}
                program:
                test$type_confusion1(&(0x7f0000000000)=@f1=0xff)
                mutate_buffer(&(0x7f0000000040)=""/237)
                test$bf0(&(0x7f0000000140)={0x0, 0x10001, 0x2, 0x2b, 0x42, 0x20, 0x20, 0x1f})
                syz_execute_func(&(0x7f0000000180)="de8d31221e443cba344f81dc1534bf8015a1350411ce2007d24ff18ab572199e089d6983919bba8dd629334b1773d95aeee8")
                test$text_x86_16(&(0x7f00000001c0)="66b9800000c00f326635000100000f30dd630062310f30660f3a0a179c362ef26f691dad46ba4100b88b00ef0f08f33e817709ec00", 0x35)
                foo$fmt0(&(0x7f0000000200)=0x7)
                foo$anyres(&(0x7f0000000240), &(0x7f0000000280))
                test$excessive_fields1(&(0x7f00000002c0)={0xff})
                test$excessive_fields1(&(0x7f0000000300)={0x17})
                test_length15(0x4, 0x2)
                syz_compare(&(0x7f0000000000)='\x00', 0x1, &(0x7f0000000040)=@align0={0x401, 0x4, 0x6, 0xfffc, 0x3}, 0x18)
                syz_compare_int$2(0x2, 0x2, 0x81)
                syz_errno(0xf4)
                syz_execute_func(&(0x7f0000000080)="942218be6a28edc5cd9dd79f084dc2395ec1de75c537240555032566d42e5e83d07432c482b4ec4a1e6ed599f7acf6e8a6df")
                syz_exit(0x100)
                syz_mmap(&(0x7f0000ffb000/0x2000)=nil, 0x2000)
                
            csource_test.go:123: failed to build program:
                // autogenerated by syzkaller (https://github.com/google/syzkaller)
                
                #define _GNU_SOURCE 
                
                #include <dirent.h>
                #include <endian.h>
                #include <errno.h>
                #include <pthread.h>
                #include <signal.h>
                #include <stdarg.h>
                #include <stdint.h>
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <sys/mman.h>
                #include <sys/stat.h>
                #include <sys/types.h>
                #include <sys/wait.h>
                #include <time.h>
                #include <unistd.h>
                
                static void kill_and_wait(int pid, int* status)
                {
                	kill(pid, SIGKILL);
                	while (waitpid(-1, status, 0) != pid) {
                	}
                }
                
                static void sleep_ms(uint64_t ms)
                {
                	usleep(ms * 1000);
                }
                
                static uint64_t current_time_ms(void)
                {
                	struct timespec ts;
                	if (clock_gettime(CLOCK_MONOTONIC, &ts))
                	exit(1);
                	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
                }
                
                static void use_temporary_dir(void)
                {
                	char tmpdir_template[] = "./syzkaller.XXXXXX";
                	char* tmpdir = mkdtemp(tmpdir_template);
                	if (!tmpdir)
                	exit(1);
                	if (chmod(tmpdir, 0777))
                	exit(1);
                	if (chdir(tmpdir))
                	exit(1);
                }
                
                static void remove_dir(const char* dir)
                {
                	DIR* dp;
                	struct dirent* ep;
                	dp = opendir(dir);
                	if (dp == NULL)
                	exit(1);
                	while ((ep = readdir(dp))) {
                		if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
                			continue;
                		char filename[FILENAME_MAX];
                		snprintf(filename, sizeof(filename), "%s/%s", dir, ep->d_name);
                		struct stat st;
                		if (lstat(filename, &st))
                	exit(1);
                		if (S_ISDIR(st.st_mode)) {
                			remove_dir(filename);
                			continue;
                		}
                		if (unlink(filename))
                	exit(1);
                	}
                	closedir(dp);
                	if (rmdir(dir))
                	exit(1);
                }
                
                static void thread_start(void* (*fn)(void*), void* arg)
                {
                	pthread_t th;
                	pthread_attr_t attr;
                	pthread_attr_init(&attr);
                	pthread_attr_setstacksize(&attr, 128 << 10);
                	int i;
                	for (i = 0; i < 100; i++) {
                		if (pthread_create(&th, &attr, fn, arg) == 0) {
                			pthread_attr_destroy(&attr);
                			return;
                		}
                		if (errno == EAGAIN) {
                			usleep(50);
                			continue;
                		}
                		break;
                	}
                	exit(1);
                }
                
                typedef struct {
                	pthread_mutex_t mu;
                	pthread_cond_t cv;
                	int state;
                } event_t;
                
                static void event_init(event_t* ev)
                {
                	if (pthread_mutex_init(&ev->mu, 0))
                	exit(1);
                	if (pthread_cond_init(&ev->cv, 0))
                	exit(1);
                	ev->state = 0;
                }
                
                static void event_reset(event_t* ev)
                {
                	ev->state = 0;
                }
                
                static void event_set(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	if (ev->state)
                	exit(1);
                	ev->state = 1;
                	pthread_mutex_unlock(&ev->mu);
                	pthread_cond_broadcast(&ev->cv);
                }
                
                static void event_wait(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	while (!ev->state)
                		pthread_cond_wait(&ev->cv, &ev->mu);
                	pthread_mutex_unlock(&ev->mu);
                }
                
                static int event_isset(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                static int event_timedwait(event_t* ev, uint64_t timeout)
                {
                	uint64_t start = current_time_ms();
                	uint64_t now = start;
                	pthread_mutex_lock(&ev->mu);
                	for (;;) {
                		if (ev->state)
                			break;
                		uint64_t remain = timeout - (now - start);
                		struct timespec ts;
                		ts.tv_sec = remain / 1000;
                		ts.tv_nsec = (remain % 1000) * 1000 * 1000;
                		pthread_cond_timedwait(&ev->cv, &ev->mu, &ts);
                		now = current_time_ms();
                		if (now - start > timeout)
                			break;
                	}
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                #define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
                #define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))
                
                static long syz_mmap(volatile long a0, volatile long a1)
                {
                	return (long)mmap((void*)a0, a1, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0);
                }
                
                static long syz_errno(volatile long v)
                {
                	errno = v;
                	return v == 0 ? 0 : -1;
                }
                
                static long syz_exit(volatile long status)
                {
                	_exit(status);
                	return 0;
                }
                
                static long syz_compare(volatile long want, volatile long want_len, volatile long got, volatile long got_len)
                {
                	if (want_len != got_len) {
                		errno = EBADF;
                		goto error;
                	}
                	if (memcmp((void*)want, (void*)got, want_len)) {
                		errno = EINVAL;
                		goto error;
                	}
                	return 0;
                
                error:
                	return -1;
                }
                
                static long syz_compare_int(volatile long n, ...)
                {
                	va_list args;
                	va_start(args, n);
                	long v0 = va_arg(args, long);
                	long v1 = va_arg(args, long);
                	long v2 = va_arg(args, long);
                	long v3 = va_arg(args, long);
                	va_end(args);
                	if (n < 2 || n > 4)
                		return errno = E2BIG, -1;
                	if (n <= 2 && v2 != 0)
                		return errno = EFAULT, -1;
                	if (n <= 3 && v3 != 0)
                		return errno = EFAULT, -1;
                	if (v0 != v1)
                		return errno = EINVAL, -1;
                	if (n > 2 && v0 != v2)
                		return errno = EINVAL, -1;
                	if (n > 3 && v0 != v3)
                		return errno = EINVAL, -1;
                	return 0;
                }
                
                static long syz_execute_func(volatile long text)
                {
                	volatile long p[8] = {0};
                	(void)p;
                ((void (*)(void))(text))();
                	return 0;
                }
                
                struct thread_t {
                	int created, call;
                	event_t ready, done;
                };
                
                static struct thread_t threads[16];
                static void execute_call(int call);
                static int running;
                
                static void* thr(void* arg)
                {
                	struct thread_t* th = (struct thread_t*)arg;
                	for (;;) {
                		event_wait(&th->ready);
                		event_reset(&th->ready);
                		execute_call(th->call);
                		__atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
                		event_set(&th->done);
                	}
                	return 0;
                }
                
                static void execute_one(void)
                {
                	int i, call, thread;
                	for (call = 0; call < 16; call++) {
                		for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0])); thread++) {
                			struct thread_t* th = &threads[thread];
                			if (!th->created) {
                				th->created = 1;
                				event_init(&th->ready);
                				event_init(&th->done);
                				event_set(&th->done);
                				thread_start(thr, th);
                			}
                			if (!event_isset(&th->done))
                				continue;
                			event_reset(&th->done);
                			th->call = call;
                			__atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
                			event_set(&th->ready);
                			event_timedwait(&th->done, 45);
                			break;
                		}
                	}
                	for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
                		sleep_ms(1);
                }
                
                static void execute_one(void);
                
                #define WAIT_FLAGS 0
                
                static void loop(void)
                {
                	int iter;
                	for (iter = 0;; iter++) {
                		char cwdbuf[32];
                		sprintf(cwdbuf, "./%d", iter);
                		if (mkdir(cwdbuf, 0777))
                	exit(1);
                		int pid = fork();
                		if (pid < 0)
                	exit(1);
                		if (pid == 0) {
                			if (chdir(cwdbuf))
                	exit(1);
                			execute_one();
                			exit(0);
                		}
                		int status = 0;
                		uint64_t start = current_time_ms();
                		for (;;) {
                			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
                				break;
                			sleep_ms(1);
                			if (current_time_ms() - start < 5 * 1000)
                				continue;
                			kill_and_wait(pid, &status);
                			break;
                		}
                		remove_dir(cwdbuf);
                	}
                }
                
                #ifndef SYS_foo
                #define SYS_foo 0
                #endif
                #ifndef SYS_mutate_buffer
                #define SYS_mutate_buffer 0
                #endif
                #ifndef SYS_test
                #define SYS_test 0
                #endif
                #ifndef SYS_test_length15
                #define SYS_test_length15 0
                #endif
                
                void execute_call(int call)
                {
                		switch (call) {
                	case 0:
                *(uint8_t*)0x20000000 = -1;
                		syscall(SYS_test, 0x20000000, 0, 0, 0, 0, 0);
                		break;
                	case 1:
                		syscall(SYS_mutate_buffer, 0x20000040);
                		break;
                	case 2:
                STORE_BY_BITMASK(uint16_t, , 0x20000140, 0, 0, 10);
                *(uint64_t*)0x20000148 = 0x10001;
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 2, 0, 5);
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 0x2b, 5, 6);
                STORE_BY_BITMASK(uint32_t, , 0x20000150, 0x42, 11, 15);
                STORE_BY_BITMASK(uint16_t, , 0x20000154, 0x20, 0, 11);
                STORE_BY_BITMASK(uint16_t, htobe16, 0x20000156, 0x20, 0, 11);
                *(uint8_t*)0x20000158 = 0x1f;
                		syscall(SYS_test, 0x20000140, 0, 0, 0, 0, 0);
                		break;
                	case 3:
                memcpy((void*)0x20000180, "\xde\x8d\x31\x22\x1e\x44\x3c\xba\x34\x4f\x81\xdc\x15\x34\xbf\x80\x15\xa1\x35\x04\x11\xce\x20\x07\xd2\x4f\xf1\x8a\xb5\x72\x19\x9e\x08\x9d\x69\x83\x91\x9b\xba\x8d\xd6\x29\x33\x4b\x17\x73\xd9\x5a\xee\xe8", 50);
                		syz_execute_func(0x20000180);
                		break;
                	case 4:
                memcpy((void*)0x200001c0, "\x66\xb9\x80\x00\x00\xc0\x0f\x32\x66\x35\x00\x01\x00\x00\x0f\x30\xdd\x63\x00\x62\x31\x0f\x30\x66\x0f\x3a\x0a\x17\x9c\x36\x2e\xf2\x6f\x69\x1d\xad\x46\xba\x41\x00\xb8\x8b\x00\xef\x0f\x08\xf3\x3e\x81\x77\x09\xec\x00", 53);
                		syscall(SYS_test, 0x200001c0, 0x35, 0, 0, 0, 0);
                		break;
                	case 5:
                sprintf((char*)0x20000200, "%020llu", (long long)7);
                		syscall(SYS_foo, 0x20000200, 0);
                		break;
                	case 6:
                		syscall(SYS_foo, 0x20000240, 0x20000280);
                		break;
                	case 7:
                *(uint8_t*)0x200002c0 = -1;
                		syscall(SYS_test, 0x200002c0, 0, 0, 0, 0, 0);
                		break;
                	case 8:
                *(uint8_t*)0x20000300 = 0x17;
                		syscall(SYS_test, 0x20000300, 0, 0, 0, 0, 0);
                		break;
                	case 9:
                		syscall(SYS_test_length15, 4, 2);
                		break;
                	case 10:
                memcpy((void*)0x20000000, "\000", 1);
                *(uint16_t*)0x20000040 = 0x401;
                *(uint32_t*)0x20000044 = 4;
                *(uint8_t*)0x20000048 = 6;
                *(uint16_t*)0x2000004a = 0xfffc;
                *(uint64_t*)0x20000050 = 3;
                		syz_compare(0x20000000, 1, 0x20000040, 0x18);
                		break;
                	case 11:
                		syz_compare_int(2, 2, 0x81, 0, 0);
                		break;
                	case 12:
                		syz_errno(0xf4);
                		break;
                	case 13:
                memcpy((void*)0x20000080, "\x94\x22\x18\xbe\x6a\x28\xed\xc5\xcd\x9d\xd7\x9f\x08\x4d\xc2\x39\x5e\xc1\xde\x75\xc5\x37\x24\x05\x55\x03\x25\x66\xd4\x2e\x5e\x83\xd0\x74\x32\xc4\x82\xb4\xec\x4a\x1e\x6e\xd5\x99\xf7\xac\xf6\xe8\xa6\xdf", 50);
                		syz_execute_func(0x20000080);
                		break;
                	case 14:
                		syz_exit(0x100);
                		break;
                	case 15:
                		syz_mmap(0x20ffb000, 0x2000);
                		break;
                	}
                
                }
                int main(void)
                {
                		syz_mmap(0x20000000, 0x1000000);
                			use_temporary_dir();
                			loop();
                	return 0;
                }
                
                In file included from /usr/include/bits/errno.h:26,
                                 from /usr/include/errno.h:28,
                                 from <stdin>:7:
                /usr/include/linux/errno.h:1:10: fatal error: asm/errno.h: No such file or directory
                    1 | #include <asm/errno.h>
                      |          ^~~~~~~~~~~~~
                compilation terminated.
                
                compiler invocation: gcc [-o /tmp/syz-executor498979945 -DGOOS_test=1 -DGOARCH_32_fork_shmem=1 -DHOSTGOOS_linux=1 -x c - -m32 -static -O2 -pthread -Wall -Werror -Wparentheses -Wunused-const-variable -Wframe-larger-than=16384 -Wno-overflow]
        --- FAIL: TestGenerate/test/32_fork_shmem/4 (0.08s)
            csource_test.go:122: opts: {Threaded:true Collide:false Repeat:true RepeatTimes:10 Procs:0 Sandbox:none Fault:false FaultCall:0 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false USB:false UseTmpDir:true HandleSegv:false Repro:false Trace:false}
                program:
                test$type_confusion1(&(0x7f0000000000)=@f1=0xff)
                mutate_buffer(&(0x7f0000000040)=""/237)
                test$bf0(&(0x7f0000000140)={0x0, 0x10001, 0x2, 0x2b, 0x42, 0x20, 0x20, 0x1f})
                syz_execute_func(&(0x7f0000000180)="de8d31221e443cba344f81dc1534bf8015a1350411ce2007d24ff18ab572199e089d6983919bba8dd629334b1773d95aeee8")
                test$text_x86_16(&(0x7f00000001c0)="66b9800000c00f326635000100000f30dd630062310f30660f3a0a179c362ef26f691dad46ba4100b88b00ef0f08f33e817709ec00", 0x35)
                foo$fmt0(&(0x7f0000000200)=0x7)
                foo$anyres(&(0x7f0000000240), &(0x7f0000000280))
                test$excessive_fields1(&(0x7f00000002c0)={0xff})
                test$excessive_fields1(&(0x7f0000000300)={0x17})
                test_length15(0x4, 0x2)
                syz_compare(&(0x7f0000000000)='\x00', 0x1, &(0x7f0000000040)=@align0={0x401, 0x4, 0x6, 0xfffc, 0x3}, 0x18)
                syz_compare_int$2(0x2, 0x2, 0x81)
                syz_errno(0xf4)
                syz_execute_func(&(0x7f0000000080)="942218be6a28edc5cd9dd79f084dc2395ec1de75c537240555032566d42e5e83d07432c482b4ec4a1e6ed599f7acf6e8a6df")
                syz_exit(0x100)
                syz_mmap(&(0x7f0000ffb000/0x2000)=nil, 0x2000)
                
            csource_test.go:123: failed to build program:
                // autogenerated by syzkaller (https://github.com/google/syzkaller)
                
                #define _GNU_SOURCE 
                
                #include <dirent.h>
                #include <endian.h>
                #include <errno.h>
                #include <pthread.h>
                #include <signal.h>
                #include <stdarg.h>
                #include <stdint.h>
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <sys/mman.h>
                #include <sys/stat.h>
                #include <sys/types.h>
                #include <sys/wait.h>
                #include <time.h>
                #include <unistd.h>
                
                static void kill_and_wait(int pid, int* status)
                {
                	kill(pid, SIGKILL);
                	while (waitpid(-1, status, 0) != pid) {
                	}
                }
                
                static void sleep_ms(uint64_t ms)
                {
                	usleep(ms * 1000);
                }
                
                static uint64_t current_time_ms(void)
                {
                	struct timespec ts;
                	if (clock_gettime(CLOCK_MONOTONIC, &ts))
                	exit(1);
                	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
                }
                
                static void use_temporary_dir(void)
                {
                	char tmpdir_template[] = "./syzkaller.XXXXXX";
                	char* tmpdir = mkdtemp(tmpdir_template);
                	if (!tmpdir)
                	exit(1);
                	if (chmod(tmpdir, 0777))
                	exit(1);
                	if (chdir(tmpdir))
                	exit(1);
                }
                
                static void remove_dir(const char* dir)
                {
                	DIR* dp;
                	struct dirent* ep;
                	dp = opendir(dir);
                	if (dp == NULL)
                	exit(1);
                	while ((ep = readdir(dp))) {
                		if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
                			continue;
                		char filename[FILENAME_MAX];
                		snprintf(filename, sizeof(filename), "%s/%s", dir, ep->d_name);
                		struct stat st;
                		if (lstat(filename, &st))
                	exit(1);
                		if (S_ISDIR(st.st_mode)) {
                			remove_dir(filename);
                			continue;
                		}
                		if (unlink(filename))
                	exit(1);
                	}
                	closedir(dp);
                	if (rmdir(dir))
                	exit(1);
                }
                
                static void thread_start(void* (*fn)(void*), void* arg)
                {
                	pthread_t th;
                	pthread_attr_t attr;
                	pthread_attr_init(&attr);
                	pthread_attr_setstacksize(&attr, 128 << 10);
                	int i;
                	for (i = 0; i < 100; i++) {
                		if (pthread_create(&th, &attr, fn, arg) == 0) {
                			pthread_attr_destroy(&attr);
                			return;
                		}
                		if (errno == EAGAIN) {
                			usleep(50);
                			continue;
                		}
                		break;
                	}
                	exit(1);
                }
                
                typedef struct {
                	pthread_mutex_t mu;
                	pthread_cond_t cv;
                	int state;
                } event_t;
                
                static void event_init(event_t* ev)
                {
                	if (pthread_mutex_init(&ev->mu, 0))
                	exit(1);
                	if (pthread_cond_init(&ev->cv, 0))
                	exit(1);
                	ev->state = 0;
                }
                
                static void event_reset(event_t* ev)
                {
                	ev->state = 0;
                }
                
                static void event_set(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	if (ev->state)
                	exit(1);
                	ev->state = 1;
                	pthread_mutex_unlock(&ev->mu);
                	pthread_cond_broadcast(&ev->cv);
                }
                
                static void event_wait(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	while (!ev->state)
                		pthread_cond_wait(&ev->cv, &ev->mu);
                	pthread_mutex_unlock(&ev->mu);
                }
                
                static int event_isset(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                static int event_timedwait(event_t* ev, uint64_t timeout)
                {
                	uint64_t start = current_time_ms();
                	uint64_t now = start;
                	pthread_mutex_lock(&ev->mu);
                	for (;;) {
                		if (ev->state)
                			break;
                		uint64_t remain = timeout - (now - start);
                		struct timespec ts;
                		ts.tv_sec = remain / 1000;
                		ts.tv_nsec = (remain % 1000) * 1000 * 1000;
                		pthread_cond_timedwait(&ev->cv, &ev->mu, &ts);
                		now = current_time_ms();
                		if (now - start > timeout)
                			break;
                	}
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                #define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
                #define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))
                
                static long syz_mmap(volatile long a0, volatile long a1)
                {
                	return (long)mmap((void*)a0, a1, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0);
                }
                
                static long syz_errno(volatile long v)
                {
                	errno = v;
                	return v == 0 ? 0 : -1;
                }
                
                static long syz_exit(volatile long status)
                {
                	_exit(status);
                	return 0;
                }
                
                static long syz_compare(volatile long want, volatile long want_len, volatile long got, volatile long got_len)
                {
                	if (want_len != got_len) {
                		errno = EBADF;
                		goto error;
                	}
                	if (memcmp((void*)want, (void*)got, want_len)) {
                		errno = EINVAL;
                		goto error;
                	}
                	return 0;
                
                error:
                	return -1;
                }
                
                static long syz_compare_int(volatile long n, ...)
                {
                	va_list args;
                	va_start(args, n);
                	long v0 = va_arg(args, long);
                	long v1 = va_arg(args, long);
                	long v2 = va_arg(args, long);
                	long v3 = va_arg(args, long);
                	va_end(args);
                	if (n < 2 || n > 4)
                		return errno = E2BIG, -1;
                	if (n <= 2 && v2 != 0)
                		return errno = EFAULT, -1;
                	if (n <= 3 && v3 != 0)
                		return errno = EFAULT, -1;
                	if (v0 != v1)
                		return errno = EINVAL, -1;
                	if (n > 2 && v0 != v2)
                		return errno = EINVAL, -1;
                	if (n > 3 && v0 != v3)
                		return errno = EINVAL, -1;
                	return 0;
                }
                
                static void loop();
                static int do_sandbox_none(void)
                {
                	loop();
                	return 0;
                }
                
                static long syz_execute_func(volatile long text)
                {
                	volatile long p[8] = {0};
                	(void)p;
                ((void (*)(void))(text))();
                	return 0;
                }
                
                struct thread_t {
                	int created, call;
                	event_t ready, done;
                };
                
                static struct thread_t threads[16];
                static void execute_call(int call);
                static int running;
                
                static void* thr(void* arg)
                {
                	struct thread_t* th = (struct thread_t*)arg;
                	for (;;) {
                		event_wait(&th->ready);
                		event_reset(&th->ready);
                		execute_call(th->call);
                		__atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
                		event_set(&th->done);
                	}
                	return 0;
                }
                
                static void execute_one(void)
                {
                	int i, call, thread;
                	for (call = 0; call < 16; call++) {
                		for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0])); thread++) {
                			struct thread_t* th = &threads[thread];
                			if (!th->created) {
                				th->created = 1;
                				event_init(&th->ready);
                				event_init(&th->done);
                				event_set(&th->done);
                				thread_start(thr, th);
                			}
                			if (!event_isset(&th->done))
                				continue;
                			event_reset(&th->done);
                			th->call = call;
                			__atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
                			event_set(&th->ready);
                			event_timedwait(&th->done, 45);
                			break;
                		}
                	}
                	for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
                		sleep_ms(1);
                }
                
                static void execute_one(void);
                
                #define WAIT_FLAGS 0
                
                static void loop(void)
                {
                	int iter;
                	for (iter = 0; iter < 10; iter++) {
                		char cwdbuf[32];
                		sprintf(cwdbuf, "./%d", iter);
                		if (mkdir(cwdbuf, 0777))
                	exit(1);
                		int pid = fork();
                		if (pid < 0)
                	exit(1);
                		if (pid == 0) {
                			if (chdir(cwdbuf))
                	exit(1);
                			execute_one();
                			exit(0);
                		}
                		int status = 0;
                		uint64_t start = current_time_ms();
                		for (;;) {
                			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
                				break;
                			sleep_ms(1);
                			if (current_time_ms() - start < 5 * 1000)
                				continue;
                			kill_and_wait(pid, &status);
                			break;
                		}
                		remove_dir(cwdbuf);
                	}
                }
                
                #ifndef SYS_foo
                #define SYS_foo 0
                #endif
                #ifndef SYS_mutate_buffer
                #define SYS_mutate_buffer 0
                #endif
                #ifndef SYS_test
                #define SYS_test 0
                #endif
                #ifndef SYS_test_length15
                #define SYS_test_length15 0
                #endif
                
                void execute_call(int call)
                {
                		switch (call) {
                	case 0:
                *(uint8_t*)0x20000000 = -1;
                		syscall(SYS_test, 0x20000000, 0, 0, 0, 0, 0);
                		break;
                	case 1:
                		syscall(SYS_mutate_buffer, 0x20000040);
                		break;
                	case 2:
                STORE_BY_BITMASK(uint16_t, , 0x20000140, 0, 0, 10);
                *(uint64_t*)0x20000148 = 0x10001;
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 2, 0, 5);
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 0x2b, 5, 6);
                STORE_BY_BITMASK(uint32_t, , 0x20000150, 0x42, 11, 15);
                STORE_BY_BITMASK(uint16_t, , 0x20000154, 0x20, 0, 11);
                STORE_BY_BITMASK(uint16_t, htobe16, 0x20000156, 0x20, 0, 11);
                *(uint8_t*)0x20000158 = 0x1f;
                		syscall(SYS_test, 0x20000140, 0, 0, 0, 0, 0);
                		break;
                	case 3:
                memcpy((void*)0x20000180, "\xde\x8d\x31\x22\x1e\x44\x3c\xba\x34\x4f\x81\xdc\x15\x34\xbf\x80\x15\xa1\x35\x04\x11\xce\x20\x07\xd2\x4f\xf1\x8a\xb5\x72\x19\x9e\x08\x9d\x69\x83\x91\x9b\xba\x8d\xd6\x29\x33\x4b\x17\x73\xd9\x5a\xee\xe8", 50);
                		syz_execute_func(0x20000180);
                		break;
                	case 4:
                memcpy((void*)0x200001c0, "\x66\xb9\x80\x00\x00\xc0\x0f\x32\x66\x35\x00\x01\x00\x00\x0f\x30\xdd\x63\x00\x62\x31\x0f\x30\x66\x0f\x3a\x0a\x17\x9c\x36\x2e\xf2\x6f\x69\x1d\xad\x46\xba\x41\x00\xb8\x8b\x00\xef\x0f\x08\xf3\x3e\x81\x77\x09\xec\x00", 53);
                		syscall(SYS_test, 0x200001c0, 0x35, 0, 0, 0, 0);
                		break;
                	case 5:
                sprintf((char*)0x20000200, "%020llu", (long long)7);
                		syscall(SYS_foo, 0x20000200, 0);
                		break;
                	case 6:
                		syscall(SYS_foo, 0x20000240, 0x20000280);
                		break;
                	case 7:
                *(uint8_t*)0x200002c0 = -1;
                		syscall(SYS_test, 0x200002c0, 0, 0, 0, 0, 0);
                		break;
                	case 8:
                *(uint8_t*)0x20000300 = 0x17;
                		syscall(SYS_test, 0x20000300, 0, 0, 0, 0, 0);
                		break;
                	case 9:
                		syscall(SYS_test_length15, 4, 2);
                		break;
                	case 10:
                memcpy((void*)0x20000000, "\000", 1);
                *(uint16_t*)0x20000040 = 0x401;
                *(uint32_t*)0x20000044 = 4;
                *(uint8_t*)0x20000048 = 6;
                *(uint16_t*)0x2000004a = 0xfffc;
                *(uint64_t*)0x20000050 = 3;
                		syz_compare(0x20000000, 1, 0x20000040, 0x18);
                		break;
                	case 11:
                		syz_compare_int(2, 2, 0x81, 0, 0);
                		break;
                	case 12:
                		syz_errno(0xf4);
                		break;
                	case 13:
                memcpy((void*)0x20000080, "\x94\x22\x18\xbe\x6a\x28\xed\xc5\xcd\x9d\xd7\x9f\x08\x4d\xc2\x39\x5e\xc1\xde\x75\xc5\x37\x24\x05\x55\x03\x25\x66\xd4\x2e\x5e\x83\xd0\x74\x32\xc4\x82\xb4\xec\x4a\x1e\x6e\xd5\x99\xf7\xac\xf6\xe8\xa6\xdf", 50);
                		syz_execute_func(0x20000080);
                		break;
                	case 14:
                		syz_exit(0x100);
                		break;
                	case 15:
                		syz_mmap(0x20ffb000, 0x2000);
                		break;
                	}
                
                }
                int main(void)
                {
                		syz_mmap(0x20000000, 0x1000000);
                			use_temporary_dir();
                			do_sandbox_none();
                	return 0;
                }
                
                In file included from /usr/include/bits/errno.h:26,
                                 from /usr/include/errno.h:28,
                                 from <stdin>:7:
                /usr/include/linux/errno.h:1:10: fatal error: asm/errno.h: No such file or directory
                    1 | #include <asm/errno.h>
                      |          ^~~~~~~~~~~~~
                compilation terminated.
                
                compiler invocation: gcc [-o /tmp/syz-executor370688180 -DGOOS_test=1 -DGOARCH_32_fork_shmem=1 -DHOSTGOOS_linux=1 -x c - -m32 -static -O2 -pthread -Wall -Werror -Wparentheses -Wunused-const-variable -Wframe-larger-than=16384 -Wno-overflow]
        --- FAIL: TestGenerate/test/32_fork_shmem/3 (0.09s)
            csource_test.go:122: opts: {Threaded:true Collide:false Repeat:false RepeatTimes:0 Procs:0 Sandbox:none Fault:false FaultCall:0 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false USB:false UseTmpDir:true HandleSegv:false Repro:false Trace:false}
                program:
                test$type_confusion1(&(0x7f0000000000)=@f1=0xff)
                mutate_buffer(&(0x7f0000000040)=""/237)
                test$bf0(&(0x7f0000000140)={0x0, 0x10001, 0x2, 0x2b, 0x42, 0x20, 0x20, 0x1f})
                syz_execute_func(&(0x7f0000000180)="de8d31221e443cba344f81dc1534bf8015a1350411ce2007d24ff18ab572199e089d6983919bba8dd629334b1773d95aeee8")
                test$text_x86_16(&(0x7f00000001c0)="66b9800000c00f326635000100000f30dd630062310f30660f3a0a179c362ef26f691dad46ba4100b88b00ef0f08f33e817709ec00", 0x35)
                foo$fmt0(&(0x7f0000000200)=0x7)
                foo$anyres(&(0x7f0000000240), &(0x7f0000000280))
                test$excessive_fields1(&(0x7f00000002c0)={0xff})
                test$excessive_fields1(&(0x7f0000000300)={0x17})
                test_length15(0x4, 0x2)
                syz_compare(&(0x7f0000000000)='\x00', 0x1, &(0x7f0000000040)=@align0={0x401, 0x4, 0x6, 0xfffc, 0x3}, 0x18)
                syz_compare_int$2(0x2, 0x2, 0x81)
                syz_errno(0xf4)
                syz_execute_func(&(0x7f0000000080)="942218be6a28edc5cd9dd79f084dc2395ec1de75c537240555032566d42e5e83d07432c482b4ec4a1e6ed599f7acf6e8a6df")
                syz_exit(0x100)
                syz_mmap(&(0x7f0000ffb000/0x2000)=nil, 0x2000)
                
            csource_test.go:123: failed to build program:
                // autogenerated by syzkaller (https://github.com/google/syzkaller)
                
                #define _GNU_SOURCE 
                
                #include <endian.h>
                #include <errno.h>
                #include <pthread.h>
                #include <stdarg.h>
                #include <stdint.h>
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <sys/mman.h>
                #include <sys/stat.h>
                #include <time.h>
                #include <unistd.h>
                
                static void sleep_ms(uint64_t ms)
                {
                	usleep(ms * 1000);
                }
                
                static uint64_t current_time_ms(void)
                {
                	struct timespec ts;
                	if (clock_gettime(CLOCK_MONOTONIC, &ts))
                	exit(1);
                	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
                }
                
                static void use_temporary_dir(void)
                {
                	char tmpdir_template[] = "./syzkaller.XXXXXX";
                	char* tmpdir = mkdtemp(tmpdir_template);
                	if (!tmpdir)
                	exit(1);
                	if (chmod(tmpdir, 0777))
                	exit(1);
                	if (chdir(tmpdir))
                	exit(1);
                }
                
                static void thread_start(void* (*fn)(void*), void* arg)
                {
                	pthread_t th;
                	pthread_attr_t attr;
                	pthread_attr_init(&attr);
                	pthread_attr_setstacksize(&attr, 128 << 10);
                	int i;
                	for (i = 0; i < 100; i++) {
                		if (pthread_create(&th, &attr, fn, arg) == 0) {
                			pthread_attr_destroy(&attr);
                			return;
                		}
                		if (errno == EAGAIN) {
                			usleep(50);
                			continue;
                		}
                		break;
                	}
                	exit(1);
                }
                
                typedef struct {
                	pthread_mutex_t mu;
                	pthread_cond_t cv;
                	int state;
                } event_t;
                
                static void event_init(event_t* ev)
                {
                	if (pthread_mutex_init(&ev->mu, 0))
                	exit(1);
                	if (pthread_cond_init(&ev->cv, 0))
                	exit(1);
                	ev->state = 0;
                }
                
                static void event_reset(event_t* ev)
                {
                	ev->state = 0;
                }
                
                static void event_set(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	if (ev->state)
                	exit(1);
                	ev->state = 1;
                	pthread_mutex_unlock(&ev->mu);
                	pthread_cond_broadcast(&ev->cv);
                }
                
                static void event_wait(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	while (!ev->state)
                		pthread_cond_wait(&ev->cv, &ev->mu);
                	pthread_mutex_unlock(&ev->mu);
                }
                
                static int event_isset(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                static int event_timedwait(event_t* ev, uint64_t timeout)
                {
                	uint64_t start = current_time_ms();
                	uint64_t now = start;
                	pthread_mutex_lock(&ev->mu);
                	for (;;) {
                		if (ev->state)
                			break;
                		uint64_t remain = timeout - (now - start);
                		struct timespec ts;
                		ts.tv_sec = remain / 1000;
                		ts.tv_nsec = (remain % 1000) * 1000 * 1000;
                		pthread_cond_timedwait(&ev->cv, &ev->mu, &ts);
                		now = current_time_ms();
                		if (now - start > timeout)
                			break;
                	}
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                #define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
                #define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))
                
                static long syz_mmap(volatile long a0, volatile long a1)
                {
                	return (long)mmap((void*)a0, a1, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0);
                }
                
                static long syz_errno(volatile long v)
                {
                	errno = v;
                	return v == 0 ? 0 : -1;
                }
                
                static long syz_exit(volatile long status)
                {
                	_exit(status);
                	return 0;
                }
                
                static long syz_compare(volatile long want, volatile long want_len, volatile long got, volatile long got_len)
                {
                	if (want_len != got_len) {
                		errno = EBADF;
                		goto error;
                	}
                	if (memcmp((void*)want, (void*)got, want_len)) {
                		errno = EINVAL;
                		goto error;
                	}
                	return 0;
                
                error:
                	return -1;
                }
                
                static long syz_compare_int(volatile long n, ...)
                {
                	va_list args;
                	va_start(args, n);
                	long v0 = va_arg(args, long);
                	long v1 = va_arg(args, long);
                	long v2 = va_arg(args, long);
                	long v3 = va_arg(args, long);
                	va_end(args);
                	if (n < 2 || n > 4)
                		return errno = E2BIG, -1;
                	if (n <= 2 && v2 != 0)
                		return errno = EFAULT, -1;
                	if (n <= 3 && v3 != 0)
                		return errno = EFAULT, -1;
                	if (v0 != v1)
                		return errno = EINVAL, -1;
                	if (n > 2 && v0 != v2)
                		return errno = EINVAL, -1;
                	if (n > 3 && v0 != v3)
                		return errno = EINVAL, -1;
                	return 0;
                }
                
                static void loop();
                static int do_sandbox_none(void)
                {
                	loop();
                	return 0;
                }
                
                static long syz_execute_func(volatile long text)
                {
                	volatile long p[8] = {0};
                	(void)p;
                ((void (*)(void))(text))();
                	return 0;
                }
                
                struct thread_t {
                	int created, call;
                	event_t ready, done;
                };
                
                static struct thread_t threads[16];
                static void execute_call(int call);
                static int running;
                
                static void* thr(void* arg)
                {
                	struct thread_t* th = (struct thread_t*)arg;
                	for (;;) {
                		event_wait(&th->ready);
                		event_reset(&th->ready);
                		execute_call(th->call);
                		__atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
                		event_set(&th->done);
                	}
                	return 0;
                }
                
                static void loop(void)
                {
                	int i, call, thread;
                	for (call = 0; call < 16; call++) {
                		for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0])); thread++) {
                			struct thread_t* th = &threads[thread];
                			if (!th->created) {
                				th->created = 1;
                				event_init(&th->ready);
                				event_init(&th->done);
                				event_set(&th->done);
                				thread_start(thr, th);
                			}
                			if (!event_isset(&th->done))
                				continue;
                			event_reset(&th->done);
                			th->call = call;
                			__atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
                			event_set(&th->ready);
                			event_timedwait(&th->done, 45);
                			break;
                		}
                	}
                	for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
                		sleep_ms(1);
                }
                
                #ifndef SYS_foo
                #define SYS_foo 0
                #endif
                #ifndef SYS_mutate_buffer
                #define SYS_mutate_buffer 0
                #endif
                #ifndef SYS_test
                #define SYS_test 0
                #endif
                #ifndef SYS_test_length15
                #define SYS_test_length15 0
                #endif
                
                void execute_call(int call)
                {
                		switch (call) {
                	case 0:
                *(uint8_t*)0x20000000 = -1;
                		syscall(SYS_test, 0x20000000, 0, 0, 0, 0, 0);
                		break;
                	case 1:
                		syscall(SYS_mutate_buffer, 0x20000040);
                		break;
                	case 2:
                STORE_BY_BITMASK(uint16_t, , 0x20000140, 0, 0, 10);
                *(uint64_t*)0x20000148 = 0x10001;
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 2, 0, 5);
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 0x2b, 5, 6);
                STORE_BY_BITMASK(uint32_t, , 0x20000150, 0x42, 11, 15);
                STORE_BY_BITMASK(uint16_t, , 0x20000154, 0x20, 0, 11);
                STORE_BY_BITMASK(uint16_t, htobe16, 0x20000156, 0x20, 0, 11);
                *(uint8_t*)0x20000158 = 0x1f;
                		syscall(SYS_test, 0x20000140, 0, 0, 0, 0, 0);
                		break;
                	case 3:
                memcpy((void*)0x20000180, "\xde\x8d\x31\x22\x1e\x44\x3c\xba\x34\x4f\x81\xdc\x15\x34\xbf\x80\x15\xa1\x35\x04\x11\xce\x20\x07\xd2\x4f\xf1\x8a\xb5\x72\x19\x9e\x08\x9d\x69\x83\x91\x9b\xba\x8d\xd6\x29\x33\x4b\x17\x73\xd9\x5a\xee\xe8", 50);
                		syz_execute_func(0x20000180);
                		break;
                	case 4:
                memcpy((void*)0x200001c0, "\x66\xb9\x80\x00\x00\xc0\x0f\x32\x66\x35\x00\x01\x00\x00\x0f\x30\xdd\x63\x00\x62\x31\x0f\x30\x66\x0f\x3a\x0a\x17\x9c\x36\x2e\xf2\x6f\x69\x1d\xad\x46\xba\x41\x00\xb8\x8b\x00\xef\x0f\x08\xf3\x3e\x81\x77\x09\xec\x00", 53);
                		syscall(SYS_test, 0x200001c0, 0x35, 0, 0, 0, 0);
                		break;
                	case 5:
                sprintf((char*)0x20000200, "%020llu", (long long)7);
                		syscall(SYS_foo, 0x20000200, 0);
                		break;
                	case 6:
                		syscall(SYS_foo, 0x20000240, 0x20000280);
                		break;
                	case 7:
                *(uint8_t*)0x200002c0 = -1;
                		syscall(SYS_test, 0x200002c0, 0, 0, 0, 0, 0);
                		break;
                	case 8:
                *(uint8_t*)0x20000300 = 0x17;
                		syscall(SYS_test, 0x20000300, 0, 0, 0, 0, 0);
                		break;
                	case 9:
                		syscall(SYS_test_length15, 4, 2);
                		break;
                	case 10:
                memcpy((void*)0x20000000, "\000", 1);
                *(uint16_t*)0x20000040 = 0x401;
                *(uint32_t*)0x20000044 = 4;
                *(uint8_t*)0x20000048 = 6;
                *(uint16_t*)0x2000004a = 0xfffc;
                *(uint64_t*)0x20000050 = 3;
                		syz_compare(0x20000000, 1, 0x20000040, 0x18);
                		break;
                	case 11:
                		syz_compare_int(2, 2, 0x81, 0, 0);
                		break;
                	case 12:
                		syz_errno(0xf4);
                		break;
                	case 13:
                memcpy((void*)0x20000080, "\x94\x22\x18\xbe\x6a\x28\xed\xc5\xcd\x9d\xd7\x9f\x08\x4d\xc2\x39\x5e\xc1\xde\x75\xc5\x37\x24\x05\x55\x03\x25\x66\xd4\x2e\x5e\x83\xd0\x74\x32\xc4\x82\xb4\xec\x4a\x1e\x6e\xd5\x99\xf7\xac\xf6\xe8\xa6\xdf", 50);
                		syz_execute_func(0x20000080);
                		break;
                	case 14:
                		syz_exit(0x100);
                		break;
                	case 15:
                		syz_mmap(0x20ffb000, 0x2000);
                		break;
                	}
                
                }
                int main(void)
                {
                		syz_mmap(0x20000000, 0x1000000);
                			use_temporary_dir();
                			do_sandbox_none();
                	return 0;
                }
                
                In file included from /usr/include/bits/errno.h:26,
                                 from /usr/include/errno.h:28,
                                 from <stdin>:6:
                /usr/include/linux/errno.h:1:10: fatal error: asm/errno.h: No such file or directory
                    1 | #include <asm/errno.h>
                      |          ^~~~~~~~~~~~~
                compilation terminated.
                
                compiler invocation: gcc [-o /tmp/syz-executor834041987 -DGOOS_test=1 -DGOARCH_32_fork_shmem=1 -DHOSTGOOS_linux=1 -x c - -m32 -static -O2 -pthread -Wall -Werror -Wparentheses -Wunused-const-variable -Wframe-larger-than=16384 -Wno-overflow]
        --- FAIL: TestGenerate/test/32_fork_shmem/6 (0.09s)
            csource_test.go:122: opts: {Threaded:true Collide:false Repeat:true RepeatTimes:0 Procs:4 Sandbox:none Fault:false FaultCall:0 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false USB:false UseTmpDir:true HandleSegv:false Repro:false Trace:false}
                program:
                test$type_confusion1(&(0x7f0000000000)=@f1=0xff)
                mutate_buffer(&(0x7f0000000040)=""/237)
                test$bf0(&(0x7f0000000140)={0x0, 0x10001, 0x2, 0x2b, 0x42, 0x20, 0x20, 0x1f})
                syz_execute_func(&(0x7f0000000180)="de8d31221e443cba344f81dc1534bf8015a1350411ce2007d24ff18ab572199e089d6983919bba8dd629334b1773d95aeee8")
                test$text_x86_16(&(0x7f00000001c0)="66b9800000c00f326635000100000f30dd630062310f30660f3a0a179c362ef26f691dad46ba4100b88b00ef0f08f33e817709ec00", 0x35)
                foo$fmt0(&(0x7f0000000200)=0x7)
                foo$anyres(&(0x7f0000000240), &(0x7f0000000280))
                test$excessive_fields1(&(0x7f00000002c0)={0xff})
                test$excessive_fields1(&(0x7f0000000300)={0x17})
                test_length15(0x4, 0x2)
                syz_compare(&(0x7f0000000000)='\x00', 0x1, &(0x7f0000000040)=@align0={0x401, 0x4, 0x6, 0xfffc, 0x3}, 0x18)
                syz_compare_int$2(0x2, 0x2, 0x81)
                syz_errno(0xf4)
                syz_execute_func(&(0x7f0000000080)="942218be6a28edc5cd9dd79f084dc2395ec1de75c537240555032566d42e5e83d07432c482b4ec4a1e6ed599f7acf6e8a6df")
                syz_exit(0x100)
                syz_mmap(&(0x7f0000ffb000/0x2000)=nil, 0x2000)
                
            csource_test.go:123: failed to build program:
                // autogenerated by syzkaller (https://github.com/google/syzkaller)
                
                #define _GNU_SOURCE 
                
                #include <dirent.h>
                #include <endian.h>
                #include <errno.h>
                #include <pthread.h>
                #include <signal.h>
                #include <stdarg.h>
                #include <stdint.h>
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <sys/mman.h>
                #include <sys/stat.h>
                #include <sys/types.h>
                #include <sys/wait.h>
                #include <time.h>
                #include <unistd.h>
                
                static unsigned long long procid;
                
                static void kill_and_wait(int pid, int* status)
                {
                	kill(pid, SIGKILL);
                	while (waitpid(-1, status, 0) != pid) {
                	}
                }
                
                static void sleep_ms(uint64_t ms)
                {
                	usleep(ms * 1000);
                }
                
                static uint64_t current_time_ms(void)
                {
                	struct timespec ts;
                	if (clock_gettime(CLOCK_MONOTONIC, &ts))
                	exit(1);
                	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
                }
                
                static void use_temporary_dir(void)
                {
                	char tmpdir_template[] = "./syzkaller.XXXXXX";
                	char* tmpdir = mkdtemp(tmpdir_template);
                	if (!tmpdir)
                	exit(1);
                	if (chmod(tmpdir, 0777))
                	exit(1);
                	if (chdir(tmpdir))
                	exit(1);
                }
                
                static void remove_dir(const char* dir)
                {
                	DIR* dp;
                	struct dirent* ep;
                	dp = opendir(dir);
                	if (dp == NULL)
                	exit(1);
                	while ((ep = readdir(dp))) {
                		if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
                			continue;
                		char filename[FILENAME_MAX];
                		snprintf(filename, sizeof(filename), "%s/%s", dir, ep->d_name);
                		struct stat st;
                		if (lstat(filename, &st))
                	exit(1);
                		if (S_ISDIR(st.st_mode)) {
                			remove_dir(filename);
                			continue;
                		}
                		if (unlink(filename))
                	exit(1);
                	}
                	closedir(dp);
                	if (rmdir(dir))
                	exit(1);
                }
                
                static void thread_start(void* (*fn)(void*), void* arg)
                {
                	pthread_t th;
                	pthread_attr_t attr;
                	pthread_attr_init(&attr);
                	pthread_attr_setstacksize(&attr, 128 << 10);
                	int i;
                	for (i = 0; i < 100; i++) {
                		if (pthread_create(&th, &attr, fn, arg) == 0) {
                			pthread_attr_destroy(&attr);
                			return;
                		}
                		if (errno == EAGAIN) {
                			usleep(50);
                			continue;
                		}
                		break;
                	}
                	exit(1);
                }
                
                typedef struct {
                	pthread_mutex_t mu;
                	pthread_cond_t cv;
                	int state;
                } event_t;
                
                static void event_init(event_t* ev)
                {
                	if (pthread_mutex_init(&ev->mu, 0))
                	exit(1);
                	if (pthread_cond_init(&ev->cv, 0))
                	exit(1);
                	ev->state = 0;
                }
                
                static void event_reset(event_t* ev)
                {
                	ev->state = 0;
                }
                
                static void event_set(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	if (ev->state)
                	exit(1);
                	ev->state = 1;
                	pthread_mutex_unlock(&ev->mu);
                	pthread_cond_broadcast(&ev->cv);
                }
                
                static void event_wait(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	while (!ev->state)
                		pthread_cond_wait(&ev->cv, &ev->mu);
                	pthread_mutex_unlock(&ev->mu);
                }
                
                static int event_isset(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                static int event_timedwait(event_t* ev, uint64_t timeout)
                {
                	uint64_t start = current_time_ms();
                	uint64_t now = start;
                	pthread_mutex_lock(&ev->mu);
                	for (;;) {
                		if (ev->state)
                			break;
                		uint64_t remain = timeout - (now - start);
                		struct timespec ts;
                		ts.tv_sec = remain / 1000;
                		ts.tv_nsec = (remain % 1000) * 1000 * 1000;
                		pthread_cond_timedwait(&ev->cv, &ev->mu, &ts);
                		now = current_time_ms();
                		if (now - start > timeout)
                			break;
                	}
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                #define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
                #define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))
                
                static long syz_mmap(volatile long a0, volatile long a1)
                {
                	return (long)mmap((void*)a0, a1, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0);
                }
                
                static long syz_errno(volatile long v)
                {
                	errno = v;
                	return v == 0 ? 0 : -1;
                }
                
                static long syz_exit(volatile long status)
                {
                	_exit(status);
                	return 0;
                }
                
                static long syz_compare(volatile long want, volatile long want_len, volatile long got, volatile long got_len)
                {
                	if (want_len != got_len) {
                		errno = EBADF;
                		goto error;
                	}
                	if (memcmp((void*)want, (void*)got, want_len)) {
                		errno = EINVAL;
                		goto error;
                	}
                	return 0;
                
                error:
                	return -1;
                }
                
                static long syz_compare_int(volatile long n, ...)
                {
                	va_list args;
                	va_start(args, n);
                	long v0 = va_arg(args, long);
                	long v1 = va_arg(args, long);
                	long v2 = va_arg(args, long);
                	long v3 = va_arg(args, long);
                	va_end(args);
                	if (n < 2 || n > 4)
                		return errno = E2BIG, -1;
                	if (n <= 2 && v2 != 0)
                		return errno = EFAULT, -1;
                	if (n <= 3 && v3 != 0)
                		return errno = EFAULT, -1;
                	if (v0 != v1)
                		return errno = EINVAL, -1;
                	if (n > 2 && v0 != v2)
                		return errno = EINVAL, -1;
                	if (n > 3 && v0 != v3)
                		return errno = EINVAL, -1;
                	return 0;
                }
                
                static void loop();
                static int do_sandbox_none(void)
                {
                	loop();
                	return 0;
                }
                
                static long syz_execute_func(volatile long text)
                {
                	volatile long p[8] = {0};
                	(void)p;
                ((void (*)(void))(text))();
                	return 0;
                }
                
                struct thread_t {
                	int created, call;
                	event_t ready, done;
                };
                
                static struct thread_t threads[16];
                static void execute_call(int call);
                static int running;
                
                static void* thr(void* arg)
                {
                	struct thread_t* th = (struct thread_t*)arg;
                	for (;;) {
                		event_wait(&th->ready);
                		event_reset(&th->ready);
                		execute_call(th->call);
                		__atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
                		event_set(&th->done);
                	}
                	return 0;
                }
                
                static void execute_one(void)
                {
                	int i, call, thread;
                	for (call = 0; call < 16; call++) {
                		for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0])); thread++) {
                			struct thread_t* th = &threads[thread];
                			if (!th->created) {
                				th->created = 1;
                				event_init(&th->ready);
                				event_init(&th->done);
                				event_set(&th->done);
                				thread_start(thr, th);
                			}
                			if (!event_isset(&th->done))
                				continue;
                			event_reset(&th->done);
                			th->call = call;
                			__atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
                			event_set(&th->ready);
                			event_timedwait(&th->done, 45);
                			break;
                		}
                	}
                	for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
                		sleep_ms(1);
                }
                
                static void execute_one(void);
                
                #define WAIT_FLAGS 0
                
                static void loop(void)
                {
                	int iter;
                	for (iter = 0;; iter++) {
                		char cwdbuf[32];
                		sprintf(cwdbuf, "./%d", iter);
                		if (mkdir(cwdbuf, 0777))
                	exit(1);
                		int pid = fork();
                		if (pid < 0)
                	exit(1);
                		if (pid == 0) {
                			if (chdir(cwdbuf))
                	exit(1);
                			execute_one();
                			exit(0);
                		}
                		int status = 0;
                		uint64_t start = current_time_ms();
                		for (;;) {
                			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
                				break;
                			sleep_ms(1);
                			if (current_time_ms() - start < 5 * 1000)
                				continue;
                			kill_and_wait(pid, &status);
                			break;
                		}
                		remove_dir(cwdbuf);
                	}
                }
                
                #ifndef SYS_foo
                #define SYS_foo 0
                #endif
                #ifndef SYS_mutate_buffer
                #define SYS_mutate_buffer 0
                #endif
                #ifndef SYS_test
                #define SYS_test 0
                #endif
                #ifndef SYS_test_length15
                #define SYS_test_length15 0
                #endif
                
                void execute_call(int call)
                {
                		switch (call) {
                	case 0:
                *(uint8_t*)0x20000000 = -1;
                		syscall(SYS_test, 0x20000000, 0, 0, 0, 0, 0);
                		break;
                	case 1:
                		syscall(SYS_mutate_buffer, 0x20000040);
                		break;
                	case 2:
                STORE_BY_BITMASK(uint16_t, , 0x20000140, 0, 0, 10);
                *(uint64_t*)0x20000148 = 0x10001;
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 2, 0, 5);
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 0x2b, 5, 6);
                STORE_BY_BITMASK(uint32_t, , 0x20000150, 0x42, 11, 15);
                STORE_BY_BITMASK(uint16_t, , 0x20000154, 0x20, 0, 11);
                STORE_BY_BITMASK(uint16_t, htobe16, 0x20000156, 0x20, 0, 11);
                *(uint8_t*)0x20000158 = 0x1f;
                		syscall(SYS_test, 0x20000140, 0, 0, 0, 0, 0);
                		break;
                	case 3:
                memcpy((void*)0x20000180, "\xde\x8d\x31\x22\x1e\x44\x3c\xba\x34\x4f\x81\xdc\x15\x34\xbf\x80\x15\xa1\x35\x04\x11\xce\x20\x07\xd2\x4f\xf1\x8a\xb5\x72\x19\x9e\x08\x9d\x69\x83\x91\x9b\xba\x8d\xd6\x29\x33\x4b\x17\x73\xd9\x5a\xee\xe8", 50);
                		syz_execute_func(0x20000180);
                		break;
                	case 4:
                memcpy((void*)0x200001c0, "\x66\xb9\x80\x00\x00\xc0\x0f\x32\x66\x35\x00\x01\x00\x00\x0f\x30\xdd\x63\x00\x62\x31\x0f\x30\x66\x0f\x3a\x0a\x17\x9c\x36\x2e\xf2\x6f\x69\x1d\xad\x46\xba\x41\x00\xb8\x8b\x00\xef\x0f\x08\xf3\x3e\x81\x77\x09\xec\x00", 53);
                		syscall(SYS_test, 0x200001c0, 0x35, 0, 0, 0, 0);
                		break;
                	case 5:
                sprintf((char*)0x20000200, "%020llu", (long long)7);
                		syscall(SYS_foo, 0x20000200, 0);
                		break;
                	case 6:
                		syscall(SYS_foo, 0x20000240, 0x20000280);
                		break;
                	case 7:
                *(uint8_t*)0x200002c0 = -1;
                		syscall(SYS_test, 0x200002c0, 0, 0, 0, 0, 0);
                		break;
                	case 8:
                *(uint8_t*)0x20000300 = 0x17;
                		syscall(SYS_test, 0x20000300, 0, 0, 0, 0, 0);
                		break;
                	case 9:
                		syscall(SYS_test_length15, 4, 2);
                		break;
                	case 10:
                memcpy((void*)0x20000000, "\000", 1);
                *(uint16_t*)0x20000040 = 0x401;
                *(uint32_t*)0x20000044 = 4;
                *(uint8_t*)0x20000048 = 6;
                *(uint16_t*)0x2000004a = 0xfffc;
                *(uint64_t*)0x20000050 = 3;
                		syz_compare(0x20000000, 1, 0x20000040, 0x18);
                		break;
                	case 11:
                		syz_compare_int(2, 2, 0x81, 0, 0);
                		break;
                	case 12:
                		syz_errno(0xf4);
                		break;
                	case 13:
                memcpy((void*)0x20000080, "\x94\x22\x18\xbe\x6a\x28\xed\xc5\xcd\x9d\xd7\x9f\x08\x4d\xc2\x39\x5e\xc1\xde\x75\xc5\x37\x24\x05\x55\x03\x25\x66\xd4\x2e\x5e\x83\xd0\x74\x32\xc4\x82\xb4\xec\x4a\x1e\x6e\xd5\x99\xf7\xac\xf6\xe8\xa6\xdf", 50);
                		syz_execute_func(0x20000080);
                		break;
                	case 14:
                		syz_exit(0x100);
                		break;
                	case 15:
                		syz_mmap(0x20ffb000, 0x2000);
                		break;
                	}
                
                }
                int main(void)
                {
                		syz_mmap(0x20000000, 0x1000000);
                	for (procid = 0; procid < 4; procid++) {
                		if (fork() == 0) {
                			use_temporary_dir();
                			do_sandbox_none();
                		}
                	}
                	sleep(1000000);
                	return 0;
                }
                
                In file included from /usr/include/bits/errno.h:26,
                                 from /usr/include/errno.h:28,
                                 from <stdin>:7:
                /usr/include/linux/errno.h:1:10: fatal error: asm/errno.h: No such file or directory
                    1 | #include <asm/errno.h>
                      |          ^~~~~~~~~~~~~
                compilation terminated.
                
                compiler invocation: gcc [-o /tmp/syz-executor423680808 -DGOOS_test=1 -DGOARCH_32_fork_shmem=1 -DHOSTGOOS_linux=1 -x c - -m32 -static -O2 -pthread -Wall -Werror -Wparentheses -Wunused-const-variable -Wframe-larger-than=16384 -Wno-overflow]
        --- FAIL: TestGenerate/test/32_fork_shmem/9 (0.09s)
            csource_test.go:122: opts: {Threaded:true Collide:false Repeat:true RepeatTimes:0 Procs:0 Sandbox:none Fault:false FaultCall:0 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false USB:false UseTmpDir:true HandleSegv:true Repro:false Trace:false}
                program:
                test$type_confusion1(&(0x7f0000000000)=@f1=0xff)
                mutate_buffer(&(0x7f0000000040)=""/237)
                test$bf0(&(0x7f0000000140)={0x0, 0x10001, 0x2, 0x2b, 0x42, 0x20, 0x20, 0x1f})
                syz_execute_func(&(0x7f0000000180)="de8d31221e443cba344f81dc1534bf8015a1350411ce2007d24ff18ab572199e089d6983919bba8dd629334b1773d95aeee8")
                test$text_x86_16(&(0x7f00000001c0)="66b9800000c00f326635000100000f30dd630062310f30660f3a0a179c362ef26f691dad46ba4100b88b00ef0f08f33e817709ec00", 0x35)
                foo$fmt0(&(0x7f0000000200)=0x7)
                foo$anyres(&(0x7f0000000240), &(0x7f0000000280))
                test$excessive_fields1(&(0x7f00000002c0)={0xff})
                test$excessive_fields1(&(0x7f0000000300)={0x17})
                test_length15(0x4, 0x2)
                syz_compare(&(0x7f0000000000)='\x00', 0x1, &(0x7f0000000040)=@align0={0x401, 0x4, 0x6, 0xfffc, 0x3}, 0x18)
                syz_compare_int$2(0x2, 0x2, 0x81)
                syz_errno(0xf4)
                syz_execute_func(&(0x7f0000000080)="942218be6a28edc5cd9dd79f084dc2395ec1de75c537240555032566d42e5e83d07432c482b4ec4a1e6ed599f7acf6e8a6df")
                syz_exit(0x100)
                syz_mmap(&(0x7f0000ffb000/0x2000)=nil, 0x2000)
                
            csource_test.go:123: failed to build program:
                // autogenerated by syzkaller (https://github.com/google/syzkaller)
                
                #define _GNU_SOURCE 
                
                #include <dirent.h>
                #include <endian.h>
                #include <errno.h>
                #include <pthread.h>
                #include <setjmp.h>
                #include <signal.h>
                #include <stdarg.h>
                #include <stdint.h>
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <sys/mman.h>
                #include <sys/stat.h>
                #include <sys/types.h>
                #include <sys/wait.h>
                #include <time.h>
                #include <unistd.h>
                
                static __thread int skip_segv;
                static __thread jmp_buf segv_env;
                
                static void segv_handler(int sig, siginfo_t* info, void* ctx)
                {
                	uintptr_t addr = (uintptr_t)info->si_addr;
                	const uintptr_t prog_start = 1 << 20;
                	const uintptr_t prog_end = 100 << 20;
                	if (__atomic_load_n(&skip_segv, __ATOMIC_RELAXED) && (addr < prog_start || addr > prog_end)) {
                		_longjmp(segv_env, 1);
                	}
                	exit(sig);
                }
                
                static void install_segv_handler(void)
                {
                	struct sigaction sa;
                	memset(&sa, 0, sizeof(sa));
                	sa.sa_sigaction = segv_handler;
                	sa.sa_flags = SA_NODEFER | SA_SIGINFO;
                	sigaction(SIGSEGV, &sa, NULL);
                	sigaction(SIGBUS, &sa, NULL);
                }
                
                #define NONFAILING(...) { __atomic_fetch_add(&skip_segv, 1, __ATOMIC_SEQ_CST); if (_setjmp(segv_env) == 0) { __VA_ARGS__; } __atomic_fetch_sub(&skip_segv, 1, __ATOMIC_SEQ_CST); }
                
                static void kill_and_wait(int pid, int* status)
                {
                	kill(pid, SIGKILL);
                	while (waitpid(-1, status, 0) != pid) {
                	}
                }
                
                static void sleep_ms(uint64_t ms)
                {
                	usleep(ms * 1000);
                }
                
                static uint64_t current_time_ms(void)
                {
                	struct timespec ts;
                	if (clock_gettime(CLOCK_MONOTONIC, &ts))
                	exit(1);
                	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
                }
                
                static void use_temporary_dir(void)
                {
                	char tmpdir_template[] = "./syzkaller.XXXXXX";
                	char* tmpdir = mkdtemp(tmpdir_template);
                	if (!tmpdir)
                	exit(1);
                	if (chmod(tmpdir, 0777))
                	exit(1);
                	if (chdir(tmpdir))
                	exit(1);
                }
                
                static void remove_dir(const char* dir)
                {
                	DIR* dp;
                	struct dirent* ep;
                	dp = opendir(dir);
                	if (dp == NULL)
                	exit(1);
                	while ((ep = readdir(dp))) {
                		if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
                			continue;
                		char filename[FILENAME_MAX];
                		snprintf(filename, sizeof(filename), "%s/%s", dir, ep->d_name);
                		struct stat st;
                		if (lstat(filename, &st))
                	exit(1);
                		if (S_ISDIR(st.st_mode)) {
                			remove_dir(filename);
                			continue;
                		}
                		if (unlink(filename))
                	exit(1);
                	}
                	closedir(dp);
                	if (rmdir(dir))
                	exit(1);
                }
                
                static void thread_start(void* (*fn)(void*), void* arg)
                {
                	pthread_t th;
                	pthread_attr_t attr;
                	pthread_attr_init(&attr);
                	pthread_attr_setstacksize(&attr, 128 << 10);
                	int i;
                	for (i = 0; i < 100; i++) {
                		if (pthread_create(&th, &attr, fn, arg) == 0) {
                			pthread_attr_destroy(&attr);
                			return;
                		}
                		if (errno == EAGAIN) {
                			usleep(50);
                			continue;
                		}
                		break;
                	}
                	exit(1);
                }
                
                typedef struct {
                	pthread_mutex_t mu;
                	pthread_cond_t cv;
                	int state;
                } event_t;
                
                static void event_init(event_t* ev)
                {
                	if (pthread_mutex_init(&ev->mu, 0))
                	exit(1);
                	if (pthread_cond_init(&ev->cv, 0))
                	exit(1);
                	ev->state = 0;
                }
                
                static void event_reset(event_t* ev)
                {
                	ev->state = 0;
                }
                
                static void event_set(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	if (ev->state)
                	exit(1);
                	ev->state = 1;
                	pthread_mutex_unlock(&ev->mu);
                	pthread_cond_broadcast(&ev->cv);
                }
                
                static void event_wait(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	while (!ev->state)
                		pthread_cond_wait(&ev->cv, &ev->mu);
                	pthread_mutex_unlock(&ev->mu);
                }
                
                static int event_isset(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                static int event_timedwait(event_t* ev, uint64_t timeout)
                {
                	uint64_t start = current_time_ms();
                	uint64_t now = start;
                	pthread_mutex_lock(&ev->mu);
                	for (;;) {
                		if (ev->state)
                			break;
                		uint64_t remain = timeout - (now - start);
                		struct timespec ts;
                		ts.tv_sec = remain / 1000;
                		ts.tv_nsec = (remain % 1000) * 1000 * 1000;
                		pthread_cond_timedwait(&ev->cv, &ev->mu, &ts);
                		now = current_time_ms();
                		if (now - start > timeout)
                			break;
                	}
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                #define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
                #define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))
                
                static long syz_mmap(volatile long a0, volatile long a1)
                {
                	return (long)mmap((void*)a0, a1, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0);
                }
                
                static long syz_errno(volatile long v)
                {
                	errno = v;
                	return v == 0 ? 0 : -1;
                }
                
                static long syz_exit(volatile long status)
                {
                	_exit(status);
                	return 0;
                }
                
                static long syz_compare(volatile long want, volatile long want_len, volatile long got, volatile long got_len)
                {
                	if (want_len != got_len) {
                		errno = EBADF;
                		goto error;
                	}
                	if (memcmp((void*)want, (void*)got, want_len)) {
                		errno = EINVAL;
                		goto error;
                	}
                	return 0;
                
                error:
                	return -1;
                }
                
                static long syz_compare_int(volatile long n, ...)
                {
                	va_list args;
                	va_start(args, n);
                	long v0 = va_arg(args, long);
                	long v1 = va_arg(args, long);
                	long v2 = va_arg(args, long);
                	long v3 = va_arg(args, long);
                	va_end(args);
                	if (n < 2 || n > 4)
                		return errno = E2BIG, -1;
                	if (n <= 2 && v2 != 0)
                		return errno = EFAULT, -1;
                	if (n <= 3 && v3 != 0)
                		return errno = EFAULT, -1;
                	if (v0 != v1)
                		return errno = EINVAL, -1;
                	if (n > 2 && v0 != v2)
                		return errno = EINVAL, -1;
                	if (n > 3 && v0 != v3)
                		return errno = EINVAL, -1;
                	return 0;
                }
                
                static void loop();
                static int do_sandbox_none(void)
                {
                	loop();
                	return 0;
                }
                
                static long syz_execute_func(volatile long text)
                {
                	volatile long p[8] = {0};
                	(void)p;
                	NONFAILING(((void (*)(void))(text))());
                	return 0;
                }
                
                struct thread_t {
                	int created, call;
                	event_t ready, done;
                };
                
                static struct thread_t threads[16];
                static void execute_call(int call);
                static int running;
                
                static void* thr(void* arg)
                {
                	struct thread_t* th = (struct thread_t*)arg;
                	for (;;) {
                		event_wait(&th->ready);
                		event_reset(&th->ready);
                		execute_call(th->call);
                		__atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
                		event_set(&th->done);
                	}
                	return 0;
                }
                
                static void execute_one(void)
                {
                	int i, call, thread;
                	for (call = 0; call < 16; call++) {
                		for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0])); thread++) {
                			struct thread_t* th = &threads[thread];
                			if (!th->created) {
                				th->created = 1;
                				event_init(&th->ready);
                				event_init(&th->done);
                				event_set(&th->done);
                				thread_start(thr, th);
                			}
                			if (!event_isset(&th->done))
                				continue;
                			event_reset(&th->done);
                			th->call = call;
                			__atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
                			event_set(&th->ready);
                			event_timedwait(&th->done, 45);
                			break;
                		}
                	}
                	for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
                		sleep_ms(1);
                }
                
                static void execute_one(void);
                
                #define WAIT_FLAGS 0
                
                static void loop(void)
                {
                	int iter;
                	for (iter = 0;; iter++) {
                		char cwdbuf[32];
                		sprintf(cwdbuf, "./%d", iter);
                		if (mkdir(cwdbuf, 0777))
                	exit(1);
                		int pid = fork();
                		if (pid < 0)
                	exit(1);
                		if (pid == 0) {
                			if (chdir(cwdbuf))
                	exit(1);
                			execute_one();
                			exit(0);
                		}
                		int status = 0;
                		uint64_t start = current_time_ms();
                		for (;;) {
                			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
                				break;
                			sleep_ms(1);
                			if (current_time_ms() - start < 5 * 1000)
                				continue;
                			kill_and_wait(pid, &status);
                			break;
                		}
                		remove_dir(cwdbuf);
                	}
                }
                
                #ifndef SYS_foo
                #define SYS_foo 0
                #endif
                #ifndef SYS_mutate_buffer
                #define SYS_mutate_buffer 0
                #endif
                #ifndef SYS_test
                #define SYS_test 0
                #endif
                #ifndef SYS_test_length15
                #define SYS_test_length15 0
                #endif
                
                void execute_call(int call)
                {
                		switch (call) {
                	case 0:
                		NONFAILING(*(uint8_t*)0x20000000 = -1);
                		syscall(SYS_test, 0x20000000, 0, 0, 0, 0, 0);
                		break;
                	case 1:
                		syscall(SYS_mutate_buffer, 0x20000040);
                		break;
                	case 2:
                		NONFAILING(STORE_BY_BITMASK(uint16_t, , 0x20000140, 0, 0, 10));
                		NONFAILING(*(uint64_t*)0x20000148 = 0x10001);
                		NONFAILING(STORE_BY_BITMASK(uint16_t, , 0x20000150, 2, 0, 5));
                		NONFAILING(STORE_BY_BITMASK(uint16_t, , 0x20000150, 0x2b, 5, 6));
                		NONFAILING(STORE_BY_BITMASK(uint32_t, , 0x20000150, 0x42, 11, 15));
                		NONFAILING(STORE_BY_BITMASK(uint16_t, , 0x20000154, 0x20, 0, 11));
                		NONFAILING(STORE_BY_BITMASK(uint16_t, htobe16, 0x20000156, 0x20, 0, 11));
                		NONFAILING(*(uint8_t*)0x20000158 = 0x1f);
                		syscall(SYS_test, 0x20000140, 0, 0, 0, 0, 0);
                		break;
                	case 3:
                		NONFAILING(memcpy((void*)0x20000180, "\xde\x8d\x31\x22\x1e\x44\x3c\xba\x34\x4f\x81\xdc\x15\x34\xbf\x80\x15\xa1\x35\x04\x11\xce\x20\x07\xd2\x4f\xf1\x8a\xb5\x72\x19\x9e\x08\x9d\x69\x83\x91\x9b\xba\x8d\xd6\x29\x33\x4b\x17\x73\xd9\x5a\xee\xe8", 50));
                		syz_execute_func(0x20000180);
                		break;
                	case 4:
                		NONFAILING(memcpy((void*)0x200001c0, "\x66\xb9\x80\x00\x00\xc0\x0f\x32\x66\x35\x00\x01\x00\x00\x0f\x30\xdd\x63\x00\x62\x31\x0f\x30\x66\x0f\x3a\x0a\x17\x9c\x36\x2e\xf2\x6f\x69\x1d\xad\x46\xba\x41\x00\xb8\x8b\x00\xef\x0f\x08\xf3\x3e\x81\x77\x09\xec\x00", 53));
                		syscall(SYS_test, 0x200001c0, 0x35, 0, 0, 0, 0);
                		break;
                	case 5:
                		NONFAILING(sprintf((char*)0x20000200, "%020llu", (long long)7));
                		syscall(SYS_foo, 0x20000200, 0);
                		break;
                	case 6:
                		syscall(SYS_foo, 0x20000240, 0x20000280);
                		break;
                	case 7:
                		NONFAILING(*(uint8_t*)0x200002c0 = -1);
                		syscall(SYS_test, 0x200002c0, 0, 0, 0, 0, 0);
                		break;
                	case 8:
                		NONFAILING(*(uint8_t*)0x20000300 = 0x17);
                		syscall(SYS_test, 0x20000300, 0, 0, 0, 0, 0);
                		break;
                	case 9:
                		syscall(SYS_test_length15, 4, 2);
                		break;
                	case 10:
                		NONFAILING(memcpy((void*)0x20000000, "\000", 1));
                		NONFAILING(*(uint16_t*)0x20000040 = 0x401);
                		NONFAILING(*(uint32_t*)0x20000044 = 4);
                		NONFAILING(*(uint8_t*)0x20000048 = 6);
                		NONFAILING(*(uint16_t*)0x2000004a = 0xfffc);
                		NONFAILING(*(uint64_t*)0x20000050 = 3);
                		syz_compare(0x20000000, 1, 0x20000040, 0x18);
                		break;
                	case 11:
                		syz_compare_int(2, 2, 0x81, 0, 0);
                		break;
                	case 12:
                		syz_errno(0xf4);
                		break;
                	case 13:
                		NONFAILING(memcpy((void*)0x20000080, "\x94\x22\x18\xbe\x6a\x28\xed\xc5\xcd\x9d\xd7\x9f\x08\x4d\xc2\x39\x5e\xc1\xde\x75\xc5\x37\x24\x05\x55\x03\x25\x66\xd4\x2e\x5e\x83\xd0\x74\x32\xc4\x82\xb4\xec\x4a\x1e\x6e\xd5\x99\xf7\xac\xf6\xe8\xa6\xdf", 50));
                		syz_execute_func(0x20000080);
                		break;
                	case 14:
                		syz_exit(0x100);
                		break;
                	case 15:
                		syz_mmap(0x20ffb000, 0x2000);
                		break;
                	}
                
                }
                int main(void)
                {
                		syz_mmap(0x20000000, 0x1000000);
                	install_segv_handler();
                			use_temporary_dir();
                			do_sandbox_none();
                	return 0;
                }
                
                In file included from /usr/include/bits/errno.h:26,
                                 from /usr/include/errno.h:28,
                                 from <stdin>:7:
                /usr/include/linux/errno.h:1:10: fatal error: asm/errno.h: No such file or directory
                    1 | #include <asm/errno.h>
                      |          ^~~~~~~~~~~~~
                compilation terminated.
                
                compiler invocation: gcc [-o /tmp/syz-executor900099377 -DGOOS_test=1 -DGOARCH_32_fork_shmem=1 -DHOSTGOOS_linux=1 -x c - -m32 -static -O2 -pthread -Wall -Werror -Wparentheses -Wunused-const-variable -Wframe-larger-than=16384 -Wno-overflow]
        --- FAIL: TestGenerate/test/32_fork_shmem/1 (0.10s)
            csource_test.go:122: opts: {Threaded:true Collide:false Repeat:true RepeatTimes:0 Procs:0 Sandbox:none Fault:false FaultCall:0 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false USB:false UseTmpDir:true HandleSegv:false Repro:false Trace:false}
                program:
                test$type_confusion1(&(0x7f0000000000)=@f1=0xff)
                mutate_buffer(&(0x7f0000000040)=""/237)
                test$bf0(&(0x7f0000000140)={0x0, 0x10001, 0x2, 0x2b, 0x42, 0x20, 0x20, 0x1f})
                syz_execute_func(&(0x7f0000000180)="de8d31221e443cba344f81dc1534bf8015a1350411ce2007d24ff18ab572199e089d6983919bba8dd629334b1773d95aeee8")
                test$text_x86_16(&(0x7f00000001c0)="66b9800000c00f326635000100000f30dd630062310f30660f3a0a179c362ef26f691dad46ba4100b88b00ef0f08f33e817709ec00", 0x35)
                foo$fmt0(&(0x7f0000000200)=0x7)
                foo$anyres(&(0x7f0000000240), &(0x7f0000000280))
                test$excessive_fields1(&(0x7f00000002c0)={0xff})
                test$excessive_fields1(&(0x7f0000000300)={0x17})
                test_length15(0x4, 0x2)
                syz_compare(&(0x7f0000000000)='\x00', 0x1, &(0x7f0000000040)=@align0={0x401, 0x4, 0x6, 0xfffc, 0x3}, 0x18)
                syz_compare_int$2(0x2, 0x2, 0x81)
                syz_errno(0xf4)
                syz_execute_func(&(0x7f0000000080)="942218be6a28edc5cd9dd79f084dc2395ec1de75c537240555032566d42e5e83d07432c482b4ec4a1e6ed599f7acf6e8a6df")
                syz_exit(0x100)
                syz_mmap(&(0x7f0000ffb000/0x2000)=nil, 0x2000)
                
            csource_test.go:123: failed to build program:
                // autogenerated by syzkaller (https://github.com/google/syzkaller)
                
                #define _GNU_SOURCE 
                
                #include <dirent.h>
                #include <endian.h>
                #include <errno.h>
                #include <pthread.h>
                #include <signal.h>
                #include <stdarg.h>
                #include <stdint.h>
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <sys/mman.h>
                #include <sys/stat.h>
                #include <sys/types.h>
                #include <sys/wait.h>
                #include <time.h>
                #include <unistd.h>
                
                static void kill_and_wait(int pid, int* status)
                {
                	kill(pid, SIGKILL);
                	while (waitpid(-1, status, 0) != pid) {
                	}
                }
                
                static void sleep_ms(uint64_t ms)
                {
                	usleep(ms * 1000);
                }
                
                static uint64_t current_time_ms(void)
                {
                	struct timespec ts;
                	if (clock_gettime(CLOCK_MONOTONIC, &ts))
                	exit(1);
                	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
                }
                
                static void use_temporary_dir(void)
                {
                	char tmpdir_template[] = "./syzkaller.XXXXXX";
                	char* tmpdir = mkdtemp(tmpdir_template);
                	if (!tmpdir)
                	exit(1);
                	if (chmod(tmpdir, 0777))
                	exit(1);
                	if (chdir(tmpdir))
                	exit(1);
                }
                
                static void remove_dir(const char* dir)
                {
                	DIR* dp;
                	struct dirent* ep;
                	dp = opendir(dir);
                	if (dp == NULL)
                	exit(1);
                	while ((ep = readdir(dp))) {
                		if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
                			continue;
                		char filename[FILENAME_MAX];
                		snprintf(filename, sizeof(filename), "%s/%s", dir, ep->d_name);
                		struct stat st;
                		if (lstat(filename, &st))
                	exit(1);
                		if (S_ISDIR(st.st_mode)) {
                			remove_dir(filename);
                			continue;
                		}
                		if (unlink(filename))
                	exit(1);
                	}
                	closedir(dp);
                	if (rmdir(dir))
                	exit(1);
                }
                
                static void thread_start(void* (*fn)(void*), void* arg)
                {
                	pthread_t th;
                	pthread_attr_t attr;
                	pthread_attr_init(&attr);
                	pthread_attr_setstacksize(&attr, 128 << 10);
                	int i;
                	for (i = 0; i < 100; i++) {
                		if (pthread_create(&th, &attr, fn, arg) == 0) {
                			pthread_attr_destroy(&attr);
                			return;
                		}
                		if (errno == EAGAIN) {
                			usleep(50);
                			continue;
                		}
                		break;
                	}
                	exit(1);
                }
                
                typedef struct {
                	pthread_mutex_t mu;
                	pthread_cond_t cv;
                	int state;
                } event_t;
                
                static void event_init(event_t* ev)
                {
                	if (pthread_mutex_init(&ev->mu, 0))
                	exit(1);
                	if (pthread_cond_init(&ev->cv, 0))
                	exit(1);
                	ev->state = 0;
                }
                
                static void event_reset(event_t* ev)
                {
                	ev->state = 0;
                }
                
                static void event_set(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	if (ev->state)
                	exit(1);
                	ev->state = 1;
                	pthread_mutex_unlock(&ev->mu);
                	pthread_cond_broadcast(&ev->cv);
                }
                
                static void event_wait(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	while (!ev->state)
                		pthread_cond_wait(&ev->cv, &ev->mu);
                	pthread_mutex_unlock(&ev->mu);
                }
                
                static int event_isset(event_t* ev)
                {
                	pthread_mutex_lock(&ev->mu);
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                static int event_timedwait(event_t* ev, uint64_t timeout)
                {
                	uint64_t start = current_time_ms();
                	uint64_t now = start;
                	pthread_mutex_lock(&ev->mu);
                	for (;;) {
                		if (ev->state)
                			break;
                		uint64_t remain = timeout - (now - start);
                		struct timespec ts;
                		ts.tv_sec = remain / 1000;
                		ts.tv_nsec = (remain % 1000) * 1000 * 1000;
                		pthread_cond_timedwait(&ev->cv, &ev->mu, &ts);
                		now = current_time_ms();
                		if (now - start > timeout)
                			break;
                	}
                	int res = ev->state;
                	pthread_mutex_unlock(&ev->mu);
                	return res;
                }
                
                #define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
                #define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))
                
                static long syz_mmap(volatile long a0, volatile long a1)
                {
                	return (long)mmap((void*)a0, a1, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0);
                }
                
                static long syz_errno(volatile long v)
                {
                	errno = v;
                	return v == 0 ? 0 : -1;
                }
                
                static long syz_exit(volatile long status)
                {
                	_exit(status);
                	return 0;
                }
                
                static long syz_compare(volatile long want, volatile long want_len, volatile long got, volatile long got_len)
                {
                	if (want_len != got_len) {
                		errno = EBADF;
                		goto error;
                	}
                	if (memcmp((void*)want, (void*)got, want_len)) {
                		errno = EINVAL;
                		goto error;
                	}
                	return 0;
                
                error:
                	return -1;
                }
                
                static long syz_compare_int(volatile long n, ...)
                {
                	va_list args;
                	va_start(args, n);
                	long v0 = va_arg(args, long);
                	long v1 = va_arg(args, long);
                	long v2 = va_arg(args, long);
                	long v3 = va_arg(args, long);
                	va_end(args);
                	if (n < 2 || n > 4)
                		return errno = E2BIG, -1;
                	if (n <= 2 && v2 != 0)
                		return errno = EFAULT, -1;
                	if (n <= 3 && v3 != 0)
                		return errno = EFAULT, -1;
                	if (v0 != v1)
                		return errno = EINVAL, -1;
                	if (n > 2 && v0 != v2)
                		return errno = EINVAL, -1;
                	if (n > 3 && v0 != v3)
                		return errno = EINVAL, -1;
                	return 0;
                }
                
                static void loop();
                static int do_sandbox_none(void)
                {
                	loop();
                	return 0;
                }
                
                static long syz_execute_func(volatile long text)
                {
                	volatile long p[8] = {0};
                	(void)p;
                ((void (*)(void))(text))();
                	return 0;
                }
                
                struct thread_t {
                	int created, call;
                	event_t ready, done;
                };
                
                static struct thread_t threads[16];
                static void execute_call(int call);
                static int running;
                
                static void* thr(void* arg)
                {
                	struct thread_t* th = (struct thread_t*)arg;
                	for (;;) {
                		event_wait(&th->ready);
                		event_reset(&th->ready);
                		execute_call(th->call);
                		__atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
                		event_set(&th->done);
                	}
                	return 0;
                }
                
                static void execute_one(void)
                {
                	int i, call, thread;
                	for (call = 0; call < 16; call++) {
                		for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0])); thread++) {
                			struct thread_t* th = &threads[thread];
                			if (!th->created) {
                				th->created = 1;
                				event_init(&th->ready);
                				event_init(&th->done);
                				event_set(&th->done);
                				thread_start(thr, th);
                			}
                			if (!event_isset(&th->done))
                				continue;
                			event_reset(&th->done);
                			th->call = call;
                			__atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
                			event_set(&th->ready);
                			event_timedwait(&th->done, 45);
                			break;
                		}
                	}
                	for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
                		sleep_ms(1);
                }
                
                static void execute_one(void);
                
                #define WAIT_FLAGS 0
                
                static void loop(void)
                {
                	int iter;
                	for (iter = 0;; iter++) {
                		char cwdbuf[32];
                		sprintf(cwdbuf, "./%d", iter);
                		if (mkdir(cwdbuf, 0777))
                	exit(1);
                		int pid = fork();
                		if (pid < 0)
                	exit(1);
                		if (pid == 0) {
                			if (chdir(cwdbuf))
                	exit(1);
                			execute_one();
                			exit(0);
                		}
                		int status = 0;
                		uint64_t start = current_time_ms();
                		for (;;) {
                			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
                				break;
                			sleep_ms(1);
                			if (current_time_ms() - start < 5 * 1000)
                				continue;
                			kill_and_wait(pid, &status);
                			break;
                		}
                		remove_dir(cwdbuf);
                	}
                }
                
                #ifndef SYS_foo
                #define SYS_foo 0
                #endif
                #ifndef SYS_mutate_buffer
                #define SYS_mutate_buffer 0
                #endif
                #ifndef SYS_test
                #define SYS_test 0
                #endif
                #ifndef SYS_test_length15
                #define SYS_test_length15 0
                #endif
                
                void execute_call(int call)
                {
                		switch (call) {
                	case 0:
                *(uint8_t*)0x20000000 = -1;
                		syscall(SYS_test, 0x20000000, 0, 0, 0, 0, 0);
                		break;
                	case 1:
                		syscall(SYS_mutate_buffer, 0x20000040);
                		break;
                	case 2:
                STORE_BY_BITMASK(uint16_t, , 0x20000140, 0, 0, 10);
                *(uint64_t*)0x20000148 = 0x10001;
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 2, 0, 5);
                STORE_BY_BITMASK(uint16_t, , 0x20000150, 0x2b, 5, 6);
                STORE_BY_BITMASK(uint32_t, , 0x20000150, 0x42, 11, 15);
                STORE_BY_BITMASK(uint16_t, , 0x20000154, 0x20, 0, 11);
                STORE_BY_BITMASK(uint16_t, htobe16, 0x20000156, 0x20, 0, 11);
                *(uint8_t*)0x20000158 = 0x1f;
                		syscall(SYS_test, 0x20000140, 0, 0, 0, 0, 0);
                		break;
                	case 3:
                memcpy((void*)0x20000180, "\xde\x8d\x31\x22\x1e\x44\x3c\xba\x34\x4f\x81\xdc\x15\x34\xbf\x80\x15\xa1\x35\x04\x11\xce\x20\x07\xd2\x4f\xf1\x8a\xb5\x72\x19\x9e\x08\x9d\x69\x83\x91\x9b\xba\x8d\xd6\x29\x33\x4b\x17\x73\xd9\x5a\xee\xe8", 50);
                		syz_execute_func(0x20000180);
                		break;
                	case 4:
                memcpy((void*)0x200001c0, "\x66\xb9\x80\x00\x00\xc0\x0f\x32\x66\x35\x00\x01\x00\x00\x0f\x30\xdd\x63\x00\x62\x31\x0f\x30\x66\x0f\x3a\x0a\x17\x9c\x36\x2e\xf2\x6f\x69\x1d\xad\x46\xba\x41\x00\xb8\x8b\x00\xef\x0f\x08\xf3\x3e\x81\x77\x09\xec\x00", 53);
                		syscall(SYS_test, 0x200001c0, 0x35, 0, 0, 0, 0);
                		break;
                	case 5:
                sprintf((char*)0x20000200, "%020llu", (long long)7);
                		syscall(SYS_foo, 0x20000200, 0);
                		break;
                	case 6:
                		syscall(SYS_foo, 0x20000240, 0x20000280);
                		break;
                	case 7:
                *(uint8_t*)0x200002c0 = -1;
                		syscall(SYS_test, 0x200002c0, 0, 0, 0, 0, 0);
                		break;
                	case 8:
                *(uint8_t*)0x20000300 = 0x17;
                		syscall(SYS_test, 0x20000300, 0, 0, 0, 0, 0);
                		break;
                	case 9:
                		syscall(SYS_test_length15, 4, 2);
                		break;
                	case 10:
                memcpy((void*)0x20000000, "\000", 1);
                *(uint16_t*)0x20000040 = 0x401;
                *(uint32_t*)0x20000044 = 4;
                *(uint8_t*)0x20000048 = 6;
                *(uint16_t*)0x2000004a = 0xfffc;
                *(uint64_t*)0x20000050 = 3;
                		syz_compare(0x20000000, 1, 0x20000040, 0x18);
                		break;
                	case 11:
                		syz_compare_int(2, 2, 0x81, 0, 0);
                		break;
                	case 12:
                		syz_errno(0xf4);
                		break;
                	case 13:
                memcpy((void*)0x20000080, "\x94\x22\x18\xbe\x6a\x28\xed\xc5\xcd\x9d\xd7\x9f\x08\x4d\xc2\x39\x5e\xc1\xde\x75\xc5\x37\x24\x05\x55\x03\x25\x66\xd4\x2e\x5e\x83\xd0\x74\x32\xc4\x82\xb4\xec\x4a\x1e\x6e\xd5\x99\xf7\xac\xf6\xe8\xa6\xdf", 50);
                		syz_execute_func(0x20000080);
                		break;
                	case 14:
                		syz_exit(0x100);
                		break;
                	case 15:
                		syz_mmap(0x20ffb000, 0x2000);
                		break;
                	}
                
                }
                int main(void)
                {
                		syz_mmap(0x20000000, 0x1000000);
                			use_temporary_dir();
                			do_sandbox_none();
                	return 0;
                }
                
                In file included from /usr/include/bits/errno.h:26,
                                 from /usr/include/errno.h:28,
                                 from <stdin>:7:
                /usr/include/linux/errno.h:1:10: fatal error: asm/errno.h: No such file or directory
                    1 | #include <asm/errno.h>
                      |          ^~~~~~~~~~~~~
                compilation terminated.
                
                compiler invocation: gcc [-o /tmp/syz-executor926272220 -DGOOS_test=1 -DGOARCH_32_fork_shmem=1 -DHOSTGOOS_linux=1 -x c - -m32 -static -O2 -pthread -Wall -Werror -Wparentheses -Wunused-const-variable -Wframe-larger-than=16384 -Wno-overflow]
        --- FAIL: TestGenerate/test/32_fork_shmem/0 (0.10s)
            csource_test.go:120: 
        --- FAIL: TestGenerate/test/32_fork_shmem/10 (0.11s)
            csource_test.go:120: 
        --- FAIL: TestGenerate/test/32_fork_shmem/11 (0.11s)
            csource_test.go:120: 
FAIL
coverage: 80.4% of statements
FAIL	github.com/google/syzkaller/pkg/csource	7.029s
ok  	github.com/google/syzkaller/pkg/db	0.691s	coverage: 64.0% of statements
ok  	github.com/google/syzkaller/pkg/email	0.069s	coverage: 88.1% of statements
?   	github.com/google/syzkaller/pkg/gce	[no test files]
?   	github.com/google/syzkaller/pkg/gcs	[no test files]
?   	github.com/google/syzkaller/pkg/hash	[no test files]
ok  	github.com/google/syzkaller/pkg/host	11.134s	coverage: 65.3% of statements
?   	github.com/google/syzkaller/pkg/html	[no test files]
ok  	github.com/google/syzkaller/pkg/ifuzz	0.407s	coverage: 81.8% of statements
?   	github.com/google/syzkaller/pkg/ifuzz/gen	[no test files]
?   	github.com/google/syzkaller/pkg/ifuzz/generated	[no test files]
ok  	github.com/google/syzkaller/pkg/instance	1.742s	coverage: 7.4% of statements
ok  	github.com/google/syzkaller/pkg/ipc	7.654s	coverage: 52.7% of statements
?   	github.com/google/syzkaller/pkg/ipc/ipcconfig	[no test files]
ok  	github.com/google/syzkaller/pkg/kd	0.029s	coverage: 72.7% of statements
ok  	github.com/google/syzkaller/pkg/log	0.029s	coverage: 77.8% of statements
ok  	github.com/google/syzkaller/pkg/mgrconfig	0.218s	coverage: 3.7% of statements
ok  	github.com/google/syzkaller/pkg/osutil	0.867s	coverage: 10.3% of statements
ok  	github.com/google/syzkaller/pkg/report	3.978s	coverage: 79.0% of statements
ok  	github.com/google/syzkaller/pkg/repro	1.360s	coverage: 26.8% of statements
?   	github.com/google/syzkaller/pkg/rpctype	[no test files]
ok  	github.com/google/syzkaller/pkg/runtest	2.934s	coverage: 60.6% of statements
ok  	github.com/google/syzkaller/pkg/serializer	0.027s	coverage: 78.1% of statements
?   	github.com/google/syzkaller/pkg/signal	[no test files]
ok  	github.com/google/syzkaller/pkg/symbolizer	0.042s	coverage: 58.7% of statements
ok  	github.com/google/syzkaller/pkg/vcs	24.988s	coverage: 65.3% of statements
ok  	github.com/google/syzkaller/prog	23.676s	coverage: 88.5% of statements
ok  	github.com/google/syzkaller/prog/test	0.538s	coverage: 67.6% of statements
?   	github.com/google/syzkaller/sys	[no test files]
?   	github.com/google/syzkaller/sys/akaros	[no test files]
?   	github.com/google/syzkaller/sys/akaros/gen	[no test files]
?   	github.com/google/syzkaller/sys/freebsd	[no test files]
?   	github.com/google/syzkaller/sys/freebsd/gen	[no test files]
?   	github.com/google/syzkaller/sys/fuchsia	[no test files]
?   	github.com/google/syzkaller/sys/fuchsia/fidlgen	[no test files]
?   	github.com/google/syzkaller/sys/fuchsia/gen	[no test files]
?   	github.com/google/syzkaller/sys/fuchsia/layout	[no test files]
ok  	github.com/google/syzkaller/sys/linux	0.929s	coverage: 16.1% of statements
?   	github.com/google/syzkaller/sys/linux/gen	[no test files]
?   	github.com/google/syzkaller/sys/netbsd	[no test files]
?   	github.com/google/syzkaller/sys/netbsd/gen	[no test files]
ok  	github.com/google/syzkaller/sys/openbsd	0.069s	coverage: 82.8% of statements
?   	github.com/google/syzkaller/sys/openbsd/gen	[no test files]
?   	github.com/google/syzkaller/sys/syz-extract	[no test files]
?   	github.com/google/syzkaller/sys/syz-sysgen	[no test files]
?   	github.com/google/syzkaller/sys/targets	[no test files]
?   	github.com/google/syzkaller/sys/test	[no test files]
?   	github.com/google/syzkaller/sys/test/gen	[no test files]
?   	github.com/google/syzkaller/sys/trusty	[no test files]
?   	github.com/google/syzkaller/sys/trusty/gen	[no test files]
?   	github.com/google/syzkaller/sys/windows	[no test files]
?   	github.com/google/syzkaller/sys/windows/gen	[no test files]
ok  	github.com/google/syzkaller/syz-ci	1.469s	coverage: 5.9% of statements
ok  	github.com/google/syzkaller/syz-fuzzer	1.083s	coverage: 3.6% of statements
ok  	github.com/google/syzkaller/syz-hub	0.785s	coverage: 11.5% of statements
ok  	github.com/google/syzkaller/syz-hub/state	0.327s	coverage: 59.3% of statements
?   	github.com/google/syzkaller/syz-manager	[no test files]
?   	github.com/google/syzkaller/tools/syz-benchcmp	[no test files]
?   	github.com/google/syzkaller/tools/syz-bisect	[no test files]
?   	github.com/google/syzkaller/tools/syz-check	[no test files]
?   	github.com/google/syzkaller/tools/syz-cover	[no test files]
?   	github.com/google/syzkaller/tools/syz-crush	[no test files]
?   	github.com/google/syzkaller/tools/syz-db	[no test files]
?   	github.com/google/syzkaller/tools/syz-execprog	[no test files]
?   	github.com/google/syzkaller/tools/syz-expand	[no test files]
?   	github.com/google/syzkaller/tools/syz-fmt	[no test files]
?   	github.com/google/syzkaller/tools/syz-imagegen	[no test files]
ok  	github.com/google/syzkaller/tools/syz-linter	1.957s	coverage: 93.4% of statements
?   	github.com/google/syzkaller/tools/syz-make	[no test files]
?   	github.com/google/syzkaller/tools/syz-mutate	[no test files]
?   	github.com/google/syzkaller/tools/syz-prog2c	[no test files]
?   	github.com/google/syzkaller/tools/syz-reporter	[no test files]
?   	github.com/google/syzkaller/tools/syz-repro	[no test files]
?   	github.com/google/syzkaller/tools/syz-reprolist	[no test files]
?   	github.com/google/syzkaller/tools/syz-runtest	[no test files]
?   	github.com/google/syzkaller/tools/syz-showprio	[no test files]
?   	github.com/google/syzkaller/tools/syz-stress	[no test files]
?   	github.com/google/syzkaller/tools/syz-symbolize	[no test files]
?   	github.com/google/syzkaller/tools/syz-testbuild	[no test files]
?   	github.com/google/syzkaller/tools/syz-trace2syz	[no test files]
ok  	github.com/google/syzkaller/tools/syz-trace2syz/parser	0.277s	coverage: 22.2% of statements
ok  	github.com/google/syzkaller/tools/syz-trace2syz/proggen	0.488s	coverage: 75.6% of statements
?   	github.com/google/syzkaller/tools/syz-tty	[no test files]
?   	github.com/google/syzkaller/tools/syz-upgrade	[no test files]
?   	github.com/google/syzkaller/tools/syz-usbgen	[no test files]
ok  	github.com/google/syzkaller/vm	10.142s	coverage: 86.0% of statements
?   	github.com/google/syzkaller/vm/adb	[no test files]
?   	github.com/google/syzkaller/vm/bhyve	[no test files]
?   	github.com/google/syzkaller/vm/gce	[no test files]
?   	github.com/google/syzkaller/vm/gvisor	[no test files]
ok  	github.com/google/syzkaller/vm/isolated	0.062s	coverage: 9.4% of statements
?   	github.com/google/syzkaller/vm/kvm	[no test files]
?   	github.com/google/syzkaller/vm/odroid	[no test files]
?   	github.com/google/syzkaller/vm/qemu	[no test files]
ok  	github.com/google/syzkaller/vm/vmimpl	0.046s	coverage: 19.0% of statements
?   	github.com/google/syzkaller/vm/vmm	[no test files]
FAIL
